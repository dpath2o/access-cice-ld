From bea6463e8af20ab46f97c2142c528c526cec5c82 Mon Sep 17 00:00:00 2001
From: dpath2o <dpath2o@mac.com>
Date: Wed, 21 Jan 2026 19:01:49 +1100
Subject: [PATCH 27/34] significant changes to ice_forcing.F90 after finding
 error to previous version

---
 cicecore/cicedyn/dynamics/ice_dyn_evp.F90    |  119 +-
 cicecore/cicedyn/dynamics/ice_dyn_shared.F90 |  139 +-
 cicecore/cicedyn/general/ice_flux.F90        |   33 +-
 cicecore/cicedyn/general/ice_forcing.F90     | 1191 +++++++++++++-----
 cicecore/cicedyn/general/ice_init.F90        |   48 +-
 cicecore/cicedyn/infrastructure/ice_grid.F90 |    4 +-
 6 files changed, 1068 insertions(+), 466 deletions(-)

diff --git a/cicecore/cicedyn/dynamics/ice_dyn_evp.F90 b/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
index c018420..9a35e0d 100644
--- a/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
+++ b/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
@@ -48,7 +48,9 @@ module ice_dyn_evp
           uvel_init, vvel_init, uvelE_init, vvelE_init, uvelN_init, vvelN_init, &
           seabed_stress_factor_LKD, seabed_stress_factor_prob, seabed_stress_method, &
           seabed_stress, Ktens, revp, &
-          coastal_drag, boundary_condition, coastal_drag_stress_factor, Cs, u0
+          lateral_drag, boundary_condition, form_func, lateral_drag_stress_factor, &
+          Cs, Cq, u_cap, u_cap_eff, C_L, u0, &
+          static_switch, quad_switch, quad_cap_switch, linear_switch
       use ice_fileunits, only: nu_diag
       use ice_exit, only: abort_ice
       use icepack_intfc, only: icepack_warnings_flush, icepack_warnings_aborted
@@ -133,7 +135,7 @@ subroutine init_evp
          load_F2_form_factors
       use ice_calendar, only: dt_dyn
       use ice_dyn_shared, only: init_dyn_shared, evp_algorithm, &
-         iceEmask, iceNmask, coastal_drag
+         iceEmask, iceNmask, lateral_drag
       use ice_dyn_evp1d, only: dyn_evp1d_init
 
 !allocate c and cd grid var. Follow structucre of eap
@@ -153,7 +155,7 @@ subroutine init_evp
 
       !------------------------------------------------
       ! form factor load or test case scenario (uniform grid)
-      if (coastal_drag) then
+      if (lateral_drag) then
          call load_F2_form_factors()
       endif
 
@@ -791,19 +793,19 @@ subroutine evp (dt)
       endif
 
       !-----------------------------------------------------------------
-      ! coastal drag function KuE/N
+      ! lateral drag function KuE/N
       !-----------------------------------------------------------------
-      if (coastal_drag) then
+      if (lateral_drag) then
          if (grid_ice == "C") then
             9000 format(a,3(1pe16.8,1x))
             ! ----------------------------------------------------------------------
             !$OMP PARALLEL DO PRIVATE(iblk) SCHEDULE(runtime)
             do iblk = 1, nblocks
-               call coastal_drag_stress_factor(nx_block          , ny_block, &
+               call lateral_drag_stress_factor(nx_block          , ny_block, &
                                                emass   (:,:,iblk),           &
                                                KuE     (:,:,iblk),           &
                                                F2E     (:,:,iblk))
-               call coastal_drag_stress_factor(nx_block          , ny_block, &
+               call lateral_drag_stress_factor(nx_block          , ny_block, &
                                                nmass   (:,:,iblk),           &
                                                KuN     (:,:,iblk),           &
                                                F2N     (:,:,iblk))
@@ -977,6 +979,50 @@ subroutine evp (dt)
 
       elseif (grid_ice == "C") then
 
+         ! defaults each timestep
+         static_switch   = c0
+         quad_switch     = c0
+         quad_cap_switch = c0
+         linear_switch   = c0
+
+         ! Set lateral-drag functional weights once per timestep (no ndte-branching)  
+         u_cap_eff = huge(1.0d0) ! lateral drag; form factor method 'quad_cap' default: cap disabled
+         if (u_cap > 0.0d0) u_cap_eff = u_cap
+
+         if (lateral_drag) then
+            select case (trim(form_func))
+            case ('static')
+               static_switch   = c1
+            case ('quad')
+               quad_switch     = c1
+            case ('quad_cap')
+               quad_cap_switch = c1
+               if (u_cap <= 0.0d0) then
+                  call abort_ice(error_message='form_func=quad_cap requires u_cap>0', &
+                                 file=__FILE__, line=__LINE__)
+               end if
+            case ('sum')
+               static_switch   = c1
+               quad_switch     = c1
+               linear_switch   = merge(c1, c0, C_L > 0.0d0)   ! your requested behavior
+            case ('sum_quad_cap')
+               static_switch   = c1
+               quad_cap_switch = c1
+               linear_switch   = merge(c1, c0, C_L > 0.0d0)
+               if (u_cap <= 0.0d0) then
+                  call abort_ice(error_message='form_func=sum_quad_cap requires u_cap>0', &
+                                 file=__FILE__, line=__LINE__)
+               end if
+            case ('linear')
+               linear_switch   = c1
+               ! only auto-default C_L in the explicit linear mode (keeps your “opt-in” semantics)
+               if (C_L <= 0.0d0) C_L = Cs / max(u0, 1.0e-12_dbl_kind)
+            case default
+               call abort_ice(error_message='Unknown form_func='//trim(form_func), &
+                              file=__FILE__, line=__LINE__)
+            end select
+         end if
+
          do ksub = 1,ndte        ! subcycling
 
             !$OMP PARALLEL DO PRIVATE(iblk)
@@ -1127,50 +1173,6 @@ subroutine evp (dt)
             enddo
             !$OMP END PARALLEL DO
 
-            ! --- Diagnostics at end of subcycling ---------------------------------
-            ! if (ksub == ndte) then
-            !    nE = count(F2E /= c0)
-            !    nN = count(F2N /= c0)
-            !    nKux = count(KuxE /= c0)
-            !    nKuy = count(KuyN /= c0)
-
-
-            !    write(nu_diag,9000) 'after stepu/v_C calls F2E min/max/avg =', &
-            !       minval(F2E, mask=F2E/=c0), maxval(F2E, mask=F2E/=c0), &
-            !       sum(F2E, mask=F2E/=c0)/real(max(1,nE), dbl_kind)
-            !    write(nu_diag,9000) 'after stepu/v_C calls F2N min/max/avg =', &
-            !       minval(F2N, mask=F2N/=c0), maxval(F2N, mask=F2N/=c0), &
-            !       sum(F2N, mask=F2N/=c0)/real(max(1,nN), dbl_kind)
-            !    write(nu_diag,9000) 'after stepu/v_C calls KuE min/max/avg =', &
-            !       minval(KuE, mask=KuE/=c0), maxval(KuE, mask=KuE/=c0), &
-            !       sum(KuE, mask=KuE/=c0)/real(max(1,nE), dbl_kind)
-            !    write(nu_diag,9000) 'after stepu/v_C calls KuN min/max/avg =', &
-            !       minval(KuN, mask=KuN/=c0), maxval(KuN, mask=KuN/=c0), &
-            !       sum(KuN, mask=KuN/=c0)/real(max(1,nN), dbl_kind)
-            !    if (nKux > 0) then
-            !    write(nu_diag,9000) 'after stepu/v_C calls KuxE min/max/avg =', &
-            !          minval(KuxE, mask=KuxE/=c0), maxval(KuxE, mask=KuxE/=c0), &
-            !          sum(KuxE, mask=KuxE/=c0)/real(nKux, dbl_kind)
-            !    else
-            !    write(nu_diag,'(a)') 'after stepu/v_C calls KuxE: all zero.'
-            !    end if
-            !    if (nKuy > 0) then
-            !    write(nu_diag,9000) 'after stepu/v_C calls KuyN min/max/avg =', &
-            !          minval(KuyN, mask=KuyN/=c0), maxval(KuyN, mask=KuyN/=c0), &
-            !          sum(KuyN, mask=KuyN/=c0)/real(nKuy, dbl_kind)
-            !    else
-            !    write(nu_diag,'(a)') 'after stepu/v_C calls KuyN: all zero.'
-            !    end if
-            !    write(nu_diag,9000) 'KuyE coast min/max/avg =', &
-            !       minval(KuyE, mask=F2E>c0), maxval(KuyE, mask=F2E>c0), &
-            !       sum(KuyE, mask=F2E>c0)/real(max(1,nE), dbl_kind)
-
-            !    write(nu_diag,9000) 'KuxN coast min/max/avg =', &
-            !       minval(KuxN, mask=F2N>c0), maxval(KuxN, mask=F2N>c0), &
-            !       sum(KuxN, mask=F2N>c0)/real(max(1,nN), dbl_kind)
-            ! end if
-            ! ----------------------------------------------------------------------
-
             ! calls ice_haloUpdate, controls bundles and masks
             call dyn_haloUpdate (halo_info,       halo_info_mask,    &
                                  field_loc_Eface, field_type_vector, &
@@ -1203,21 +1205,6 @@ subroutine evp (dt)
                                  field_loc_NEcorner, field_type_vector, &
                                  uvel, vvel)
 
-            ! if (ksub == ndte) then
-            !    nE = count(F2E /= c0);  nN = count(F2N /= c0)
-
-            !    write(nu_diag,9000) 'end-subcycle |u|_coast mean =', &
-            !       sum(sqrt(uvelE**2 + vvelE**2), mask=F2E/=c0) / real(max(1,nE),dbl_kind)
-            !    write(nu_diag,9000) 'end-subcycle |v|_coast mean =', &
-            !       sum(sqrt(uvelN**2 + vvelN**2), mask=F2N/=c0) / real(max(1,nN),dbl_kind)
-
-            !    ! Optional: relative to interior
-            !    write(nu_diag,9000) 'end-subcycle |u|_interior mean =', &
-            !       sum(sqrt(uvelE**2 + vvelE**2), mask=F2E==c0) / real(max(1, size(uvelE,1)*size(uvelE,2) - nE), dbl_kind)
-            !    write(nu_diag,9000) 'end-subcycle |v|_interior mean =', &
-            !       sum(sqrt(uvelN**2 + vvelN**2), mask=F2N==c0) / real(max(1, size(uvelN,1)*size(uvelN,2) - nN), dbl_kind)
-            ! end if
-
          enddo                     ! subcycling
 
          !-----------------------------------------------------------------
diff --git a/cicecore/cicedyn/dynamics/ice_dyn_shared.F90 b/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
index 3f7eede..de514cd 100644
--- a/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
+++ b/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
@@ -25,7 +25,7 @@ module ice_dyn_shared
       private
       public :: set_evp_parameters, stepu, stepuv_CD, stepu_C, stepv_C, &
                 principal_stress, init_dyn_shared, dyn_prep1, dyn_prep2, dyn_finish, &
-                seabed_stress_factor_LKD, seabed_stress_factor_prob, coastal_drag_stress_factor, &
+                seabed_stress_factor_LKD, seabed_stress_factor_prob, lateral_drag_stress_factor, &
                 deformations, deformationsC_T, deformationsCD_T, &
                 strain_rates, strain_rates_T, strain_rates_U_no_slip, strain_rates_U_free_slip, &
                 visc_replpress, &
@@ -56,13 +56,12 @@ module ice_dyn_shared
          elasticDamp    ! coefficient for calculating the parameter E, elastic damping parameter
 
       ! other EVP parameters
-
       character (len=char_len), public :: &
          yield_curve          , & ! 'ellipse' ('teardrop' needs further testing)
          visc_method          , & ! method for viscosity calc at U points (C, CD grids)
-         seabed_stress_method , & ! method for seabed stress calculation
+         seabed_stress_method     ! method for seabed stress calculation
                                   ! LKD: Lemieux et al. 2015, probabilistic: Dupont et al. 2022
-         boundary_condition       ! 'no_slip' (Dirchlet) or 'free_slip' (Neumann); boundary conditions
+         
 
       real (kind=dbl_kind), parameter, public :: &
          ! u0     = 5e-5_dbl_kind, & ! residual velocity for seabed stress (m/s)
@@ -143,20 +142,36 @@ module ice_dyn_shared
          threshold_hw        ! max water depth for grounding
                              ! see keel data from Amundrud et al. 2004 (JGR)
 
-      ! coastal drag parameters and settings
+      ! lateral drag parameters and settings
       logical (kind=log_kind), public :: &
-         coastal_drag       ! if true, coastal drag stress for landfast on
-
+         lateral_drag           ! enable/disable lateral drag stress computations
+      ! lateral drag switches/choices:
+      ! if boundary_condition == 'no_slip' then lateral_drag is disabled
+      ! conditions for form functions are done in evp(dt) prior to ndte loop
+      character (len=char_len), public :: &
+         boundary_condition, &  ! 'no_slip' (Dirchlet) or 'free_slip' (Neumann)
+         form_func              ! 'static', 'quad', 'sum', 'linear'
+      real(kind=dbl_kind), public :: &
+         Cs, &                  ! static function coefficient; Liu et al. (2022) eq.13; 5.0*10^{−4} (units m/s^2)
+         Cq, &                  ! quadratic coefficient (units m^-1)
+         C_L, &                 ! Linear (Rayleigh) coefficient for "linear" option: tau = mF * C_L * u; Units: 1/s
+         u_cap, &               ! quadratic capped method threshold for u/v; units m/s
+         u_cap_eff, &           ! effective cap (>=0), set in evp(dt)
+         u0                     ! residual velocity for lateral drag stress (and seabed stress) (units m/s)
+      ! lateral drag form function switches based 'form_func'
+      ! if form_func == 'sum' then static_switch = 1, and quad_switch = 1
+      real (kind=dbl_kind), public :: & 
+         static_switch, &         ! 1 (default); 1 = enable static form function, 0 = disable 
+         quad_switch,   &         ! 0 (default); 1 = enable quadratic form function, 0 = disable
+         quad_cap_switch, &       ! 0 (default); 1 = enable capped-quadratic form function, 0 = disable
+         linear_switch            ! 0 (default); 1 = enable linear form function, 0 = disable
+      ! diagnostic lateral drag stress terms
       real(kind=dbl_kind), dimension (:,:,:), allocatable, public :: &
          KuU , KuE , KuN, &
          KuxU, KuyU, &
          KuxE, KuyE, &
          KuxN, KuyN
 
-      real(kind=dbl_kind), public :: &
-         Cs, &  ! static function coefficient; Liu et al. (2022) eq.13; 1.0*10^{−4} m/s^2
-         u0     ! residual velocity for coastal drag stress (and seabed stress) (m/s)
-
       interface strain_rates_T
          module procedure strain_rates_Tdt
          module procedure strain_rates_Tdtsd
@@ -244,7 +259,7 @@ subroutine alloc_dyn_shared
             stat=ierr)
          if (ierr/=0) call abort_ice(subname//': Out of memory')
          !---------------------------------------------------------
-         ! Allocate and initialise coastal drag coefficient fields
+         ! Allocate and initialise lateral drag coefficient fields
          !---------------------------------------------------------
          allocate( &
                   KuU  (nx_block,ny_block,max_blocks), &
@@ -697,10 +712,10 @@ subroutine dyn_prep2 (nx_block,   ny_block,   &
          tauby       ! seabed stress, y-direction (N/m^2)
 
       real(kind=dbl_kind), dimension(nx_block,ny_block), intent(inout), optional :: &
-         Kux, Kuy    ! coastal drag stress factors in x- & y-directions (N/m^2)
+         Kux, Kuy    ! lateral drag stress factors in x- & y-directions (N/m^2)
       
       real(kind=dbl_kind), dimension(nx_block,ny_block), intent(out), optional :: &
-         Ku          ! coastal drag stress factor (N/m^2)
+         Ku          ! lateral drag stress factor (N/m^2)
 
       ! local variables
 
@@ -729,7 +744,7 @@ subroutine dyn_prep2 (nx_block,   ny_block,   &
          TbU      (i,j) = c0
          taubx    (i,j) = c0
          tauby    (i,j) = c0
-         if (coastal_drag) then
+         if (lateral_drag) then
             Kux (i,j) = c0
             Kuy (i,j) = c0
             Ku  (i,j) = c0
@@ -1111,7 +1126,7 @@ subroutine stepu_C (nx_block,   ny_block, &
                           uvel,       vvel,     &
                           Tb,                   &
                           Kux,        Kuy,      &
-                          Ku        )
+                          Ku)
 
       integer (kind=int_kind), intent(in) :: &
          nx_block, ny_block, & ! block dimensions
@@ -1134,12 +1149,12 @@ subroutine stepu_C (nx_block,   ny_block, &
          strintx , & ! divergence of internal ice stress, x (N/m^2)
          Cw      , & ! ocean-ice neutral drag coefficient
          vvel    , & ! y-component of velocity (m/s) interpolated to E location
-         Ku          ! coastal (lateral) stress factor (N/m^2)
+         Ku          ! lateral (lateral) stress factor (N/m^2)
 
       real (kind=dbl_kind), dimension (nx_block,ny_block), intent(inout) :: &
          uvel    , & ! x-component of velocity (m/s)
          taubx   , & ! seabed stress, x-direction (N/m^2)
-         Kux, Kuy    ! coastal (lateral) stress, x/y-directions (N/m^2)
+         Kux, Kuy    ! lateral (lateral) stress, x/y-directions (N/m^2)
 
       ! local variables
 
@@ -1156,10 +1171,13 @@ subroutine stepu_C (nx_block,   ny_block, &
          Cl
 
       ! stepu_C locals (add near other locals)
-      real(kind=dbl_kind) :: u_noCDP, du
+      real(kind=dbl_kind) :: u_noCDP, du, umag_eff
       real(kind=dbl_kind) :: sum_du_coast, sum_absu_coast
       integer(kind=int_kind) :: n_coast
 
+      ! lateral drag
+      real(kind=dbl_kind) :: umag, invccc, phi
+
       character(len=*), parameter :: subname = '(stepu_C)'
 
       sum_du_coast = c0;
@@ -1191,8 +1209,20 @@ subroutine stepu_C (nx_block,   ny_block, &
          taux = vrel*waterx(i,j) ! NOTE this is not the entire
 
          ccc = sqrt(uold**2 + vold**2) + u0
-         Cb  = Tb(i,j) / ccc ! for seabed stress
-         Cl  = Ku(i,j) / ccc ! for coastal drag stress
+         ! Cb  = Tb(i,j) / ccc ! for seabed stress
+         ! Cl  = Ku(i,j) / ccc ! for lateral drag stress
+         umag   = ccc - u0                 ! saves an extra sqrt; umag >= 0
+         invccc = c1 / ccc
+         Cb     = Tb(i,j) * invccc ! seabed stress
+
+         ! Composite lateral drag coefficient added to cca (units kg/m^2/s):
+         umag_eff = min(umag, u_cap_eff)
+         phi = (static_switch * Cs * invccc) + &
+               (quad_switch * Cq * umag) + &
+               (quad_cap_switch * Cq * umag_eff) + &
+               (linear_switch * C_L)
+         Cl  = Ku(i,j) * phi
+
          cca = (brlx + revp)*massdti(i,j) + vrel * cosw + Cb + Cl ! kg/m^2 s
          ccb = fm(i,j) + sign(c1,fm(i,j)) * vrel * sinw ! kg/m^2 s
 
@@ -1200,21 +1230,11 @@ subroutine stepu_C (nx_block,   ny_block, &
          cc1 = strintx(i,j) + forcex(i,j) + taux + massdti(i,j)*(brlx*uold + revp*uvel_init(i,j))
          uvel(i,j) = (ccb*vold + cc1) / cca ! m/s
 
-         ! --- CDP effect diagnostic (does not alter state) ---
-         ! Hypothetical velocity if CDP were disabled this substep:
-         if (Cl > 0.0d0) then
-            u_noCDP        = (ccb*vold + cc1) / (cca - Cl)
-            du             = uvel(i,j) - u_noCDP        ! negative when CDP damps |u|
-            sum_du_coast   = sum_du_coast + du
-            sum_absu_coast = sum_absu_coast + abs(u_noCDP)
-            n_coast        = n_coast + 1
-         end if
-
          ! calculate seabed stress component for outputs
          ! only needed on last iteration.
          taubx(i,j) = -uvel(i,j)*Cb
 
-         ! calculate the coastal (lateral) drag stress component for output
+         ! calculate the lateral (lateral) drag stress component for output
          Kux(i,j) = -uvel(i,j)*Cl   ! normal-to-wall at E
          Kuy(i,j) = -vvel(i,j)*Cl   ! tangential-to-wall at E
 
@@ -1237,7 +1257,7 @@ subroutine stepv_C (nx_block,   ny_block, &
                           uvel,       vvel,     &
                           Tb,                   &
                           Kux,        Kuy,      &
-                          Ku       )
+                          Ku)
 
       integer (kind=int_kind), intent(in) :: &
          nx_block, ny_block, & ! block dimensions
@@ -1260,12 +1280,12 @@ subroutine stepv_C (nx_block,   ny_block, &
          strinty , & ! divergence of internal ice stress, y (N/m^2)
          Cw      , & ! ocean-ice neutral drag coefficient
          uvel    , & ! x-component of velocity (m/s) interpolated to N location
-         Ku          ! coastal (lateral) stress factor (N/m^2)
+         Ku          ! lateral (lateral) stress factor (N/m^2)
 
       real (kind=dbl_kind), dimension (nx_block,ny_block), intent(inout) :: &
          vvel    , & ! y-component of velocity (m/s)
          tauby   , & ! seabed stress, y-direction (N/m^2)
-         Kux, Kuy    ! coastal (lateral) stress, x/y-directions (N/m^2)
+         Kux, Kuy    ! lateral (lateral) stress, x/y-directions (N/m^2)
 
       ! local variables
 
@@ -1282,9 +1302,12 @@ subroutine stepv_C (nx_block,   ny_block, &
          Cl
 
       ! stepv_C locals (add near other locals)
-      real(kind=dbl_kind) :: v_noCDP, dv
+      real(kind=dbl_kind) :: v_noCDP, dv, umag_eff
       real(kind=dbl_kind) :: sum_dv_coast, sum_absv_coast
       integer(kind=int_kind) :: n_coast
+
+      ! lateral drag
+      real(kind=dbl_kind) :: umag, invccc, phi
       
       character(len=*), parameter :: subname = '(stepv_C)'
       
@@ -1315,8 +1338,20 @@ subroutine stepv_C (nx_block,   ny_block, &
          tauy = vrel*watery(i,j) ! NOTE this is not the entire ocn stress
 
          ccc = sqrt(uold**2 + vold**2) + u0
-         Cb  = Tb(i,j) / ccc ! for seabed stress
-         Cl  = Ku(i,j) / ccc ! for coastal drag stress
+         ! Cb  = Tb(i,j) / ccc ! for seabed stress
+         ! Cl  = Ku(i,j) / ccc ! for lateral drag stress
+         umag   = ccc - u0
+         invccc = c1 / ccc
+         Cb     = Tb(i,j) * invccc ! seabed stress
+
+         ! Composite lateral drag coefficient added to cca (units kg/m^2/s):
+         umag_eff = min(umag, u_cap_eff)
+         phi = (static_switch * Cs * invccc) + &
+               (quad_switch * Cq * umag) + &
+               (quad_cap_switch * Cq * umag_eff) + &
+               (linear_switch * C_L)
+         Cl  = Ku(i,j) * phi
+
          cca = (brlx + revp)*massdti(i,j) + vrel * cosw + Cb + Cl ! kg/m^2 s
          ccb = fm(i,j) + sign(c1,fm(i,j)) * vrel * sinw ! kg/m^2 s
 
@@ -1324,21 +1359,11 @@ subroutine stepv_C (nx_block,   ny_block, &
          cc2 = strinty(i,j) + forcey(i,j) + tauy + massdti(i,j)*(brlx*vold + revp*vvel_init(i,j))
          vvel(i,j) = (-ccb*uold + cc2) / cca
 
-         ! --- CDP effect diagnostic (does not alter state) ---
-         ! Hypothetical velocity if CDP were disabled this substep:
-         if (Cl > 0.0d0) then
-            v_noCDP        = (-ccb*uold + cc2) / (cca - Cl)
-            dv             = vvel(i,j) - v_noCDP        ! negative when CDP damps |u|
-            sum_dv_coast   = sum_dv_coast + dv
-            sum_absv_coast = sum_absv_coast + abs(v_noCDP)
-            n_coast        = n_coast + 1
-         end if
-
          ! calculate seabed stress component for outputs
          ! only needed on last iteration.
          tauby(i,j) = -vvel(i,j)*Cb
 
-         ! calculate the coastal (lateral) drag stress component for output
+         ! calculate the lateral (lateral) drag stress component for output
          Kux(i,j) = -uvel(i,j)*Cl   ! tangential-to-wall at N 
          Kuy(i,j) = -vvel(i,j)*Cl   ! normal-to-wall at N
 
@@ -1429,7 +1454,7 @@ subroutine dyn_finish (nx_block, ny_block, &
       end subroutine dyn_finish
 
 !=======================================================================
-! Compute coastal (lateral) drag "Ku" (for landfast ice) based on mean
+! Compute lateral (lateral) drag "Ku" (for landfast ice) based on mean
 ! sea ice thickness and a static-gridded Form factor (describing
 ! roughness of coastaline), and one namelist parameter Cs. This is based
 ! on the work done by:
@@ -1440,7 +1465,7 @@ end subroutine dyn_finish
 ! doi: https://doi.org/10.1029/2022JC018413 
 !
 ! authors: dpath2o
-      subroutine coastal_drag_stress_factor(nx_block, ny_block, &
+      subroutine lateral_drag_stress_factor(nx_block, ny_block, &
                                             imass   ,           &
                                             Ku      ,           &
                                             F2)
@@ -1450,12 +1475,12 @@ subroutine coastal_drag_stress_factor(nx_block, ny_block, &
          implicit none
          integer(kind=int_kind), intent(in) :: nx_block, ny_block
          real(kind=dbl_kind), dimension(nx_block,ny_block), intent(in) :: &
-            imass , & ! mass of n-cell/dt (kg/m^2 s)
+            imass , & ! mass of n-cell/dt (kg/m^2 )
             F2        ! coastline form factor (drag coefficient); unitless
          real(kind=dbl_kind), dimension(nx_block,ny_block), intent(inout) :: &
-            Ku        ! coastline stress form factor; kg/m^2 * _ * m/s^2 = kg/(m*s^2) = Pascal (Pa)
-         Ku = imass * F2 * Cs
-      end subroutine coastal_drag_stress_factor
+            Ku        
+         Ku = imass * F2    ! units kg/m^2
+      end subroutine lateral_drag_stress_factor
 
 !=======================================================================
 ! Computes seabed (basal) stress factor TbU (landfast ice) based on mean
@@ -2520,9 +2545,9 @@ subroutine strain_rates_U_no_slip (nx_block,   ny_block,  &
 
          ! Delta (in the denominator of zeta, eta)
          DeltaU(i,j)   = sqrt(divergU(i,j)**2 + e_factor*(tensionU(i,j)**2 + shearU(i,j)**2))
-         ! ! ---------- Diagnostics: print coastal U only (last subcycle) ----------
+         ! ! ---------- Diagnostics: print lateral U only (last subcycle) ----------
          ! if (ksub == ndte) then
-         !    ! U(i,j) is the NE corner of T(i,j). It is "coastal" if any of the
+         !    ! U(i,j) is the NE corner of T(i,j). It is "lateral" if any of the
          !    ! four faces meeting at the corner are land (mask==0).
          !    ! Adjacent faces around U(i,j): E(i,j), E(i,j-1), N(i,j), N(i-1,j)
          !    if (i >= 2 .and. j >= 2 .and. i <= nx_block-1 .and. j <= ny_block-1) then
diff --git a/cicecore/cicedyn/general/ice_flux.F90 b/cicecore/cicedyn/general/ice_flux.F90
index 33e5cde..1ea6d39 100644
--- a/cicecore/cicedyn/general/ice_flux.F90
+++ b/cicecore/cicedyn/general/ice_flux.F90
@@ -31,6 +31,9 @@ module ice_flux
       character (char_len), public :: &
          default_season ! seasonal default values for forcing
 
+      real(kind=dbl_kind), public :: &
+         hmix_0         ! initial (or fixed if standalone) mixed layer depth
+
       !-----------------------------------------------------------------
       ! Dynamics component
       ! All variables are assumed to be on the atm or ocn thermodynamic
@@ -112,13 +115,7 @@ module ice_flux
          dardg1dt, & ! rate of area loss by ridging ice (1/s)
          dardg2dt, & ! rate of area gain by new ridges (1/s)
          dvirdgdt, & ! rate of ice volume ridged (m/s)
-         opening!,  & ! rate of opening due to divergence/shear (1/s)
-         ! KuxU,     & !
-         ! KuyU,     & ! 
-         ! KuxN,     & ! coastal drag stress components (N/m^2), x-direction N-points
-         ! KuyN,     & ! coastal drag stress components (N/m^2), y-direction N-points
-         ! KuxE,     & ! coastal drag stress components (N/m^2), x-direction E-points
-         ! KuyE        ! coastal drag stress components (N/m^2), y-direction E-points
+         opening     ! rate of opening due to divergence/shear (1/s)
 
       real (kind=dbl_kind), dimension (:,:,:,:), allocatable, public :: &
        ! ridging diagnostics in categories
@@ -153,10 +150,7 @@ module ice_flux
          fmE      , & ! Coriolis param. * mass in E-cell (kg/s)
          TbE      , & ! factor for seabed stress (N/m^2)
          fmN      , & ! Coriolis param. * mass in N-cell (kg/s)
-         TbN      !, & ! factor for seabed stress (N/m^2)
-         ! KuU      , & ! 
-         ! KuN      , & ! coastal drag stress (N/m^2) at N-points
-         ! KuE          ! coastal drag stress (N/m^2) at E-points
+         TbN          ! factor for seabed stress (N/m^2)
 
       !-----------------------------------------------------------------
       ! Thermodynamic component
@@ -666,15 +660,6 @@ subroutine alloc_flux
          stresspU   (nx_block,ny_block,max_blocks), & ! sigma11+sigma22
          stressmU   (nx_block,ny_block,max_blocks), & ! sigma11-sigma22
          stress12U  (nx_block,ny_block,max_blocks), & ! sigma12
-         ! KuU        (nx_block,ny_block,max_blocks),  & ! coastal drag stress at U (B-grid)
-         ! KuE        (nx_block,ny_block,max_blocks),  & ! coastal drag stress at E (C-grid)
-         ! KuN        (nx_block,ny_block,max_blocks),  & ! coastal drag stress at N (C-grid)
-         ! KuxU       (nx_block,ny_block,max_blocks),  & ! coastal drag stress x-comp (U)
-         ! KuyU       (nx_block,ny_block,max_blocks),  & ! coastal drag stress y-comp (U)
-         ! KuxE       (nx_block,ny_block,max_blocks),  & ! coastal drag stress x-comp (E)
-         ! KuyE       (nx_block,ny_block,max_blocks),  & ! coastal drag stress y-comp (E)
-         ! KuxN       (nx_block,ny_block,max_blocks),  & ! coastal drag stress x-comp (N)
-         ! KuyN       (nx_block,ny_block,max_blocks),  & ! coastal drag stress y-comp (N)
          stat=ierr)
       if (ierr/=0) call abort_ice('(alloc_flux): Out of memory (C or CD grid)')
 
@@ -828,11 +813,11 @@ subroutine init_coupler_flux
       enddo
       enddo
 
-      sst   (:,:,:) = Tf(:,:,:)       ! sea surface temp (C)
-      qdp   (:,:,:) = c0              ! deep ocean heat flux (W/m^2)
-      hmix  (:,:,:) = 60              ! ocean mixed layer depth (m)
+      sst   (:,:,:) = Tf(:,:,:)         ! sea surface temp (C)
+      qdp   (:,:,:) = c0                ! deep ocean heat flux (W/m^2)
+      hmix  (:,:,:) = hmix_0            ! ocean mixed layer depth (m)
       hwater(:,:,:) = bathymetry(:,:,:) ! ocean water depth (m)
-      daice_da(:,:,:) = c0            ! data assimilation increment rate
+      daice_da(:,:,:) = c0              ! data assimilation increment rate
 
       !-----------------------------------------------------------------
       ! fluxes sent to atmosphere
diff --git a/cicecore/cicedyn/general/ice_forcing.F90 b/cicecore/cicedyn/general/ice_forcing.F90
index 4080056..1e84c68 100755
--- a/cicecore/cicedyn/general/ice_forcing.F90
+++ b/cicecore/cicedyn/general/ice_forcing.F90
@@ -144,6 +144,12 @@ module ice_forcing
   logical (kind=log_kind), public :: restore_ocn
   ! restoring time scale (days)
   integer (kind=int_kind), public :: trestore
+  ! AFIM_data() subroutine specific
+  real(kind=dbl_kind), public :: hmix_0, &  ! initial (or fixed if standalone) mixed layer depth
+                                 T_T,    &  ! SST restoring timescale [days]
+                                 T_S,    &  ! SSS restoring timescale [days]
+                                 a_0,    &  ! ice concentration threshold for taper (e.g. 0.15)
+                                 p_w        ! optional exponent (>=1), default 1.0
   ! restoring time scale (sec)
   real (kind=dbl_kind), public :: trest
   ! prints forcing debugging output if true
@@ -1948,10 +1954,677 @@ subroutine ERA5_data
     endif                   ! debug_forcing
   end subroutine ERA5_data
 
-   !=======================================================================
-   ! dpath2o, Dec.25
-   ! revised: caching + safe OpenMP + scalar u/v + per-year file advance
+   !-----------------------------------------------------------------------
+   ! AFIM_data: Ocean boundary conditions for CICE standalone runs
+   !
+   ! This routine is designed for standalone CICE configurations in which the
+   ! surface ocean fields are provided by externally gridded fields (SST, SSS, uocn, vocn)
+   ! originating from coupled ocean–sea-ice systems (e.g., ORAS, BRAN, HYCOM, MOM, etc.).
+   ! It is assumed that these fields are 'extracted' at the surface (or closest to
+   ! the air-sea boundar) and importantly without averaging across depth. 
+   ! 
+   ! Such ocean reanalysis products are dynamically consistent within their native 
+   ! coupled model, but when used to force a standalone ice model they must be applied
+   ! in a way that is consistent with CICE’s simplified mixed-layer treatment; see
+   ! subroutine icepack_ocn_mixed_layer()
+   !
+   ! Key principle:
+   !   + Temperature and salinity define the thermodynamic state of the mixed-layer that 
+   !     directly controls freezing/melting.
+   !   + In CICE's standalone slab mixed-layer, imposing potentially open-ocean SST/SSS
+   !     under consolidated ice can inject unphysical heat/freshwater and suppress ice
+   !     growth (especially when the forcing field represents open-water conditions or
+   !     has been spatially smoothed near the ice edge).
+   !
+   ! Therefore, I apply an 'ice-dependent taper' (for a lack of better term) to SST/SSS:
+   !   1) In the open-ocean SST/SSS is restored toward the external product over a period
+   !      of time (controlable by a new namelist parameter).
+   !   2) Under the sea ice, SST is constrained toward the local freezing point (and 
+   !      greatly reduce/avoid salinity restoring) so that the mixed-layer evolution remains
+   !      governed by local thermodynamics (ice growth/melt, brine rejection, and slab heat
+   !      capacity via the 'setable' `hmix_0`), rather than being overwritten by open-ocean
+   !      values.
+   !
+   ! Ocean-forced currents (uocn/vocn) do not have an 'ice-dependent taper', which I have
+   !   based on the following points:
+   !   + The ocean-forcing currents represent the large-scale, reanalysis--consistent 
+   !     advective/dynamic forcing that drives ice drift and ice–ocean relative motion.
+   !   + Artificially damping currents based on local ice concentration would likely impose
+   !     an ad hoc momentum sink and confound interpretation of dynamical sensitivity (e.g., 
+   !     changes in rheology, boundary condition, or potentially lateral drag).
+   !   + If I am to explore modification of under-ice momentum coupling, then I should 
+   !     probably be doing this via another physically based parameterisations; possibly an
+   !     ocean–ice drag coefficient, or boundary layer/stress formulation, or maybe an explicit
+   !     mixed-layer current model as proposed by A. Petty et al (2014))
+   !
+   ! author: dpath2o Jan.26
+   !-----------------------------------------------------------------------
+   ! subroutine AFIM_data(dt)
+   !    use ice_blocks, only            : nx_block, ny_block
+   !    use ice_read_write, only        : ice_read_nc, ice_open_nc, ice_close_nc
+   !    use ice_global_reductions, only : global_minval, global_maxval
+   !    use ice_domain, only            : distrb_info, nblocks
+   !    use ice_flux, only              : sss, sst, uocn, vocn, Tf ! CICE INTERNAL OCEAN 
+   !    use ice_grid, only              : hm, tmask, umask
+   !    use ice_calendar, only          : days_per_year, months_per_year, mmonth, myear, yday, mday, msec
+   !    use ice_restart_shared, only    : restart
+   !    use ice_state, only             : aice     ! needed for w(aice)
+   !    use, intrinsic :: ieee_arithmetic, only : ieee_is_finite
+   !    implicit none
+   !    real(kind=dbl_kind) :: Tf_loc, sst_sc_floor
+   !    real(kind=dbl_kind), parameter :: dT_sc_max = 0.20_dbl_kind   ! allow 0.2 C supercooling (tunable)
+   !    ! variable assignments
+   !    real(kind=dbl_kind), intent(in) :: dt
+   !    integer(kind=int_kind)          :: fid, i, j, iblk, rec0, rec1, maxrec, dataloc, fyr, modadj
+   !    real(kind=dbl_kind)             :: secday, sst_tgt, sss_tgt, u_tgt, v_tgt, vmin, vmax
+   !    logical                         :: need_read_slot1, need_read_slot2, first_half
+   !    character(len=*), parameter     :: subname = '(AFIM_data)'
+   !    ! --- cached state (persists across calls) ---
+   !    integer(kind=int_kind), save    :: last_fyr = -999999
+   !    integer(kind=int_kind), save    :: last_rec_slot(2) = (/ -999999, -999999 /)  ! slot1, slot2
+   !    ! --- local vars for weighted restoring ---
+   !    real(kind=dbl_kind)             :: a, w, wraw, sst_tgt_eff, tauT, tauS, facT, facS, TT_loc, TS_loc, a0_loc, pw_loc
+   !    integer(kind=int_kind) :: n_bad_sst, n_bad_sss, n_ocn
+   !    n_bad_sst = 0; n_bad_sss = 0; n_ocn = 0
+   !    call icepack_query_parameters(secday_out=secday)
+   !    call icepack_warnings_flush(nu_diag)
+   !    if (icepack_warnings_aborted()) call abort_ice(error_message=subname, file=__FILE__, line=__LINE__)
+   !    !---------------------------------------------------------------------
+   !    ! 1) Determine forcing year (supports ycycle logic used elsewhere)
+   !    !---------------------------------------------------------------------
+   !    modadj = abs((min(0,myear-fyear_init)/ycycle + 1) * ycycle)
+   !    fyr    = fyear_init + mod(myear - fyear_init + modadj, ycycle)
+   !    if (fyr /= last_fyr) then
+   !       call AFIM_files(fyr)                 ! updates F_AFIM -> ORAS_YYYY.nc
+   !       last_fyr = fyr
+   !       last_rec_slot(1) = -999999
+   !       last_rec_slot(2) = -999999
+   !       if (my_task == master_task) then
+   !          write(nu_diag,*) subname,' switching forcing year -> ', fyr
+   !          write(nu_diag,*) subname,' F_AFIM = ', trim(F_AFIM)
+   !       endif
+   !    endif
+   !    !---------------------------------------------------------------------
+   !    ! 2) Determine which two records we need (rec0=slot1, rec1=slot2),
+   !    !    and set interpolation coefficients c1intp/c2intp.
+   !    !---------------------------------------------------------------------
+   !    dataloc = 2  ! data located at end of interval (matches your prior usage)
+   !    if (trim(ocn_data_freq) == 'monthly') then
+   !       maxrec = months_per_year
+   !       ! midpoint is at day 15, 00:00; treat (mday<15) as first half
+   !       first_half = (int(mday) < 15) .or. (int(mday) == 15 .and. int(msec) == 0)
+   !       if (first_half) then
+   !          ! slot2 = current month, slot1 = previous month (wrap within same file)
+   !          rec1 = max(1, min(maxrec, mmonth))
+   !          rec0 = rec1 - 1
+   !          if (rec0 < 1) rec0 = maxrec
+   !          call interp_coeff_monthly(2)   ! recslot=2 => first half (per your routine)
+   !       else ! slot1 = current month, slot2 = next month (wrap within same file)
+   !          rec0 = max(1, min(maxrec, mmonth))
+   !          rec1 = rec0 + 1
+   !          if (rec1 > maxrec) rec1 = 1
+   !          call interp_coeff_monthly(1)   ! recslot=1 => second half
+   !       endif
+   !    elseif (trim(ocn_data_freq) == 'weekly') then
+   !       maxrec = days_per_year / 7
+   !       rec1   = int( real(yday-1,kind=dbl_kind) / 7._dbl_kind ) + 1
+   !       rec1   = max(1, min(maxrec, rec1))
+   !       rec0   = max(1, rec1-1)
+   !       call interp_coeff(rec1, 2, secday*7._dbl_kind, dataloc)
+   !    else ! default to daily
+   !       maxrec = days_per_year
+   !       rec1   = int(yday)
+   !       rec1   = max(1, min(maxrec, rec1))
+   !       rec0   = max(1, rec1-1)
+   !       call interp_coeff(rec1, 2, secday, dataloc)
+   !    endif
+   !    !---------------------------------------------------------------------
+   !    ! 3) Read only when needed (record changed since last call).
+   !    !    slot1 holds rec0, slot2 holds rec1.
+   !    !---------------------------------------------------------------------
+   !    need_read_slot1 = (rec0 /= last_rec_slot(1))
+   !    need_read_slot2 = (rec1 /= last_rec_slot(2))
+   !    if (need_read_slot1 .or. need_read_slot2) then
+   !       if (my_task == master_task) then
+   !          write(nu_diag,*) subname,' reading records rec0/rec1 = ', rec0, rec1
+   !          write(nu_diag,*) subname,' c1intp/c2intp = ', c1intp, c2intp
+   !          write(nu_diag,*) subname,' file = ', trim(F_AFIM)
+   !       endif
+   !       call ice_open_nc(F_AFIM, fid)
+   !       ! --- slot 1 (rec0) ---
+   !       if (need_read_slot1) then
+   !          call ice_read_nc(fid, rec0, 'sst', sst_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !          call ice_read_nc(fid, rec0, 'sss', sss_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !          call ice_read_nc(fid, rec0, 'u'  , uocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !          call ice_read_nc(fid, rec0, 'v'  , vocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !          last_rec_slot(1) = rec0
+   !       endif
+   !       ! --- slot 2 (rec1) ---
+   !       if (need_read_slot2) then
+   !          if (rec1 == rec0) then
+   !             ! avoid duplicate reads; just copy slot1 -> slot2
+   !             sst_data (:,:,2,:) = sst_data (:,:,1,:)
+   !             sss_data (:,:,2,:) = sss_data (:,:,1,:)
+   !             uocn_data(:,:,2,:) = uocn_data(:,:,1,:)
+   !             vocn_data(:,:,2,:) = vocn_data(:,:,1,:)
+   !          else
+   !             call ice_read_nc(fid, rec1, 'sst', sst_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !             call ice_read_nc(fid, rec1, 'sss', sss_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !             call ice_read_nc(fid, rec1, 'u'  , uocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !             call ice_read_nc(fid, rec1, 'v'  , vocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+   !          endif
+   !          last_rec_slot(2) = rec1
+   !       endif
+   !       call ice_close_nc(fid)
+   !    endif
+   !    if ((debug_forcing .or. local_debug) .and. (my_task == master_task)) then
+   !       write(nu_diag,*) subname,' raw record stats (slot1=rec0, slot2=rec1):'
+   !       vmin = global_minval(sst_data(:,:,1,:), distrb_info, tmask)
+   !       vmax = global_maxval(sst_data(:,:,1,:), distrb_info, tmask)
+   !       write(nu_diag,*) subname,'  sst_data slot1 min/max ', vmin, vmax
+   !       vmin = global_minval(sst_data(:,:,2,:), distrb_info, tmask)
+   !       vmax = global_maxval(sst_data(:,:,2,:), distrb_info, tmask)
+   !       write(nu_diag,*) subname,'  sst_data slot2 min/max ', vmin, vmax
+   !       vmin = global_minval(sss_data(:,:,1,:), distrb_info, tmask)
+   !       vmax = global_maxval(sss_data(:,:,1,:), distrb_info, tmask)
+   !       write(nu_diag,*) subname,'  sss_data slot1 min/max ', vmin, vmax
+   !       vmin = global_minval(sss_data(:,:,2,:), distrb_info, tmask)
+   !       vmax = global_maxval(sss_data(:,:,2,:), distrb_info, tmask)
+   !       write(nu_diag,*) subname,'  sss_data slot2 min/max ', vmin, vmax
+   !    endif
+   !    !---------------------------------------------------------------------
+   !    ! 4) Apply interpolation each timestep (NO nested OpenMP; no races)
+   !    !    Now: SST/SSS use ice-dependent weighting and restoring timescales.
+   !    !---------------------------------------------------------------------
+   !    TT_loc = max(T_T, 1.0e-6_dbl_kind)   ! days, but never <=0
+   !    TS_loc = max(T_S, 1.0e-6_dbl_kind)
+   !    a0_loc = max(a_0, 1.0e-12_dbl_kind)      ! avoid divide-by-zero
+   !    pw_loc = max(p_w, 1.0_dbl_kind)
+   !    ! convert timescales from days to seconds 
+   !    tauT = max(dt, T_T * secday)
+   !    tauS = max(dt, T_S * secday)
+   !    ! restore factors (capped at 1 for stability if dt > tau)
+   !    facT = min(c1, dt / tauT)
+   !    facS = min(c1, dt / tauS)
+   !    if (my_task == master_task .and. istep == 1) then
+   !       write(nu_diag,*) subname,' T_T=',T_T,' TT_loc=',TT_loc,' tauT(s)=',tauT,' facT=',facT
+   !       write(nu_diag,*) subname,' T_S=',T_S,' TS_loc=',TS_loc,' tauS(s)=',tauS,' facS=',facS
+   !       write(nu_diag,*) subname,' a_0=',a0_loc,' p_w=',pw_loc,' ocn_data_freq=',trim(ocn_data_freq)
+   !    endif
+   !    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(iblk,i,j, &
+   !    !$OMP   sst_tgt,sss_tgt,u_tgt,v_tgt, a,w,wraw,sst_tgt_eff, Tf_loc, sst_sc_floor)
+   !    do iblk = 1, nblocks
+   !       do j = 1, ny_block
+   !          do i = 1, nx_block
+   !             if (hm(i,j,iblk) == c0) then ! if land (hm=0) then set ocn fields to 0
+   !                sst (i,j,iblk) = c0
+   !                sss (i,j,iblk) = c0
+   !                uocn(i,j,iblk) = c0
+   !                vocn(i,j,iblk) = c0
+   !             else
+   !                n_ocn = n_ocn + 1
+   !                !------------------------------------------------------
+   !                ! Time interpolation of external forcing records using a linear interpolation 
+   !                ! between two records (index 1 and 2) using coefficients (c1intp,c2intp)
+   !                ! computed earlier by interp_coeff(). The record selection depends on 
+   !                ! ocn_data_freq ('daily','weekly','monthly'). This avoids step-wise "record updates"
+   !                ! and ensures that SST/SSS/uocn/vocn vary smoothly in time at each model timestep.
+   !                !------------------------------------------------------
+   !                sst_tgt = c1intp*sst_data (i,j,1,iblk) + c2intp*sst_data (i,j,2,iblk)
+   !                sss_tgt = c1intp*sss_data (i,j,1,iblk) + c2intp*sss_data (i,j,2,iblk)
+   !                u_tgt   = c1intp*uocn_data(i,j,1,iblk) + c2intp*uocn_data(i,j,2,iblk)
+   !                v_tgt   = c1intp*vocn_data(i,j,1,iblk) + c2intp*vocn_data(i,j,2,iblk)
+   !                ! 1) Ensure targets are finite (ORAS SST can be NaN under ice)
+   !                !    Use a local freezing point as the physically consistent fallback.
+   !                Tf_loc  = Tf(i,j,iblk)
+   !                if (.not. ieee_is_finite(Tf_loc)) Tf_loc = -1.8_dbl_kind
+   !                ! Catch NaN OR out-of-range fill values
+   !                if ((.not. ieee_is_finite(sst_tgt)) .or. (sst_tgt < -10._dbl_kind) .or. (sst_tgt > 50._dbl_kind)) then
+   !                   n_bad_sst = n_bad_sst + 1
+   !                   sst_tgt = Tf_loc
+   !                endif
+   !                if ((.not. ieee_is_finite(sss_tgt)) .or. (sss_tgt <  0._dbl_kind) .or. (sss_tgt > 60._dbl_kind)) then
+   !                   n_bad_sss = n_bad_sss + 1
+   !                   sss_tgt = 34._dbl_kind
+   !                endif
+   !                ! 2) Ensure the prognostic state is finite before nudging
+   !                if (.not. ieee_is_finite(sst(i,j,iblk))) sst(i,j,iblk) = sst_tgt
+   !                if (.not. ieee_is_finite(sss(i,j,iblk))) sss(i,j,iblk) = sss_tgt
+   !                !------------------------------------------------------
+   !                ! Open-water weight w(aice), thermodynamic restoring based on ice
+   !                ! concentration to prevent imposing open-ocean SST/SSS under 
+   !                ! consolidated ice.
+   !                ! w=1 : open water (aice ~ 0)  -> full restoring to forcing
+   !                ! w=0 : consolidated ice (aice >= a0) -> no open-ocean restoring
+   !                ! a0  : concentration threshold (ice_in -> a_0; default 0.15)
+   !                ! p_w : optional exponent controlling transition sharpness
+   !                !       (ice_in -> p_w; default 1.0). Larger p_w makes the taper more ... edgey!?! 
+   !                !------------------------------------------------------
+   !                a    = aice(i,j,iblk)
+   !                if (.not. ieee_is_finite(a)) a = 0._dbl_kind
+   !                wraw = (a0_loc - a) / a0_loc
+   !                w    = min(c1, max(c0, wraw))
+   !                if (pw_loc > c1) w = w**pw_loc
+   !                !------------------------------------------------------
+   !                ! SST under ice: freezing-point constrained restoring
+   !                ! Rationale: In a slab mixed-layer, prescribing or strongly restoring to
+   !                ! open-ocean SST under winter sea ice could likely inject unrealistically
+   !                ! warm water and suppress ice growth (biasing SIA/FIA low). Under consolidated
+   !                ! ice the mixed-layer is typically close to the local freezing point; therefore 
+   !                ! the aim here is to blend the target SST toward `Tf` as ice concentration increases.
+   !                ! Effective target:
+   !                !   T_tgt_eff = w*T_forcing + (1-w)*Tf
+   !                ! Then apply a relaxation with timescale T_T (days), which controls how tightly
+   !                ! the slab mixed-layer SST follows the external product in open water.
+   !                !------------------------------------------------------
+   !                sst_tgt_eff   = w*sst_tgt + (c1 - w)*Tf_loc
+   !                sst(i,j,iblk) = sst(i,j,iblk) + facT*(sst_tgt_eff - sst(i,j,iblk))
+   !                !------------------------------------------------------
+   !                ! SSS: open-water restoring only (tapered by w)
+   !                ! Rationale: Salinity under ice is strongly influenced by local freezing/melting
+   !                ! and brine rejection. Aggressive restoring of SSS under sea ice could overwrite
+   !                ! this evolution and indirectly bias Tf and growth rates. Therefore I apply a 
+   !                ! restoring in open water and progressively turn it off as ice consolidates.
+   !                ! Equivalent to restoring toward:
+   !                !   S_tgt = w*S_forcing + (1-w)*S_model
+   !                ! Implemented as:
+   !                !   dS/dt ~ (w/tauS) * (S_forcing - S_model)
+   !                ! with timescale T_S (days).
+   !                !------------------------------------------------------
+   !                sss(i,j,iblk) = sss(i,j,iblk) + facS*w*(sss_tgt - sss(i,j,iblk))
+   !                !------------------------------------------------------
+   !                ! 6) IMPORTANT: do NOT hard-floor SST at Tf (kills freeze initiation in some orderings)
+   !                !    If you want a safety limiter, allow modest supercooling:
+   !                sst_sc_floor  = Tf_loc - dT_sc_max
+   !                sst(i,j,iblk) = max(sst(i,j,iblk), sst_sc_floor)
+   !                !------------------------------------------------------
+   !                ! Ocean currents: accept time-interpolated u/v as provided.
+   !                ! Rationale: uocn/vocn represent the large-scale ocean forcing from the reanalysis
+   !                ! and provide the advective/momentum driver for ice drift and ice–ocean relative
+   !                ! motion. Tapering currents based on sea ice concentration (`aice`) would likely
+   !                ! introduce an ad hoc momentum sink tied to the ice state and possibly confound
+   !                ! mechanical sensitivity experiments.
+   !                uocn(i,j,iblk) = u_tgt
+   !                vocn(i,j,iblk) = v_tgt
+   !             endif
+   !          enddo
+   !       enddo
+   !    enddo
+   !    !$OMP END PARALLEL DO
+   !    if ((debug_forcing .or. local_debug) .and. my_task == master_task) then
+   !       write(nu_diag,*) subname,' bad_sst=',n_bad_sst,' bad_sss=',n_bad_sss!,' ocean_pts=',n_ocn
+   !    endif
+   !    ! Recomputes freezing temperature after SSS update
+   !    call ocn_freezing_temperaturell
+   !    ! helpful prints if debuggging
+   !    if ((debug_forcing .or. local_debug) .and. my_task == master_task) then
+   !       vmin = global_minval(aice, distrb_info, tmask)
+   !       vmax = global_maxval(aice, distrb_info, tmask)
+   !       write(nu_diag,*) subname,' aice min/max ', vmin, vmax
+   !       write(nu_diag,*) subname,' global min/max after update (rec0/rec1): ', rec0, rec1
+   !       vmin = global_minval(sst ,distrb_info,tmask)
+   !       vmax = global_maxval(sst ,distrb_info,tmask)
+   !       write(nu_diag,*) subname,'  sst ', vmin, vmax
+   !       vmin = global_minval(sss ,distrb_info,tmask)
+   !       vmax = global_maxval(sss ,distrb_info,tmask)
+   !       write(nu_diag,*) subname,'  sss ', vmin, vmax
+   !       vmin = global_minval(uocn,distrb_info,umask)
+   !       vmax = global_maxval(uocn,distrb_info,umask)
+   !       write(nu_diag,*) subname,'  uocn', vmin, vmax
+   !       vmin = global_minval(vocn,distrb_info,umask)
+   !       vmax = global_maxval(vocn,distrb_info,umask)
+   !       write(nu_diag,*) subname,'  vocn', vmin, vmax
+   !    endif
+   ! end subroutine AFIM_data
+   !    subroutine AFIM_data(dt)
+
+   !    use ice_blocks, only            : nx_block, ny_block
+   !    use ice_read_write, only        : ice_read_nc, ice_open_nc, ice_close_nc
+   !    use ice_global_reductions, only : global_minval, global_maxval
+   !    use ice_domain, only            : distrb_info, nblocks
+   !    use ice_flux, only              : sss, sst, uocn, vocn, Tf
+   !    use ice_grid, only              : hm, tmask, umask
+   !    use ice_calendar, only          : days_per_year, months_per_year, mmonth, myear, yday, mday, msec
+   !    use ice_restart_shared, only    : restart
+   !    use ice_state, only             : aice
+   !    use, intrinsic :: ieee_arithmetic, only : ieee_is_finite
+   !    implicit none
+
+   !    !----------------------------
+   !    ! Inputs
+   !    !----------------------------
+   !    real(kind=dbl_kind), intent(in) :: dt
+
+   !    !----------------------------
+   !    ! Parameters / thresholds
+   !    !----------------------------
+   !    real(kind=dbl_kind), parameter :: dT_sc_max       = 0.20_dbl_kind   ! allow modest supercooling
+   !    real(kind=dbl_kind), parameter :: sst_hi_thresh   = 54.0_dbl_kind   ! degC (guard for bad units)
+   !    real(kind=dbl_kind), parameter :: sst_lo_thresh   = -10.0_dbl_kind  ! degC (guard)
+   !    real(kind=dbl_kind), parameter :: sss_hi_thresh   = 47.0_dbl_kind   ! psu
+   !    real(kind=dbl_kind), parameter :: sss_lo_thresh   =  5.0_dbl_kind   ! psu (treat <= as missing/fill)
+   !    real(kind=dbl_kind), parameter :: ispd_thresh     =  2.5_dbl_kind   ! m/s (guard)
+   !    real(kind=dbl_kind), parameter :: sss_default     = 34.0_dbl_kind   ! psu fallback
+   !    real(kind=dbl_kind), parameter :: Tf_default      = -1.8_dbl_kind   ! degC fallback
+
+   !    character(len=*), parameter :: subname = '(AFIM_data)'
+
+   !    !----------------------------
+   !    ! Locals
+   !    !----------------------------
+   !    integer(kind=int_kind) :: fid, i, j, iblk
+   !    integer(kind=int_kind) :: rec0, rec1, maxrec, dataloc, fyr, modadj
+   !    logical                :: need_read_slot1, need_read_slot2, first_half
+
+   !    real(kind=dbl_kind) :: secday
+   !    real(kind=dbl_kind) :: sst_tgt, sss_tgt, u_tgt, v_tgt
+   !    real(kind=dbl_kind) :: Tf_loc, sst_sc_floor
+   !    real(kind=dbl_kind) :: a, w, wraw, sst_tgt_eff
+   !    real(kind=dbl_kind) :: tauT, tauS, facT, facS, TT_loc, TS_loc, a0_loc, pw_loc
+   !    real(kind=dbl_kind) :: vmin, vmax
+
+   !    integer(kind=int_kind) :: nstep_day
+   !    logical                :: do_dbg, do_dbg_daily
+
+   !    ! Diagnostics counters (OpenMP reductions)
+   !    integer(kind=int_kind) :: n_ocn, n_bad_sst, n_bad_sss, n_low_sss, n_bad_uv, n_nonfinite_state
+
+   !    ! --- cached state (persists across calls) ---
+   !    integer(kind=int_kind), save :: last_fyr = -999999
+   !    integer(kind=int_kind), save :: last_rec_slot(2) = (/ -999999, -999999 /)  ! slot1, slot2
+
+   !    !----------------------------
+   !    ! Init counters
+   !    !----------------------------
+   !    n_ocn            = 0
+   !    n_bad_sst        = 0
+   !    n_bad_sss        = 0
+   !    n_low_sss        = 0
+   !    n_bad_uv         = 0
+   !    n_nonfinite_state= 0
+
+   !    ! seconds/day from Icepack
+   !    call icepack_query_parameters(secday_out=secday)
+   !    call icepack_warnings_flush(nu_diag)
+   !    if (icepack_warnings_aborted()) call abort_ice(error_message=subname, file=__FILE__, line=__LINE__)
+
+   !    ! debug cadence: first ~10 days, plus whenever debug flags are on
+   !    nstep_day    = max(1_int_kind, int(secday/dt + 0.5_dbl_kind))
+   !    do_dbg       = (debug_forcing .or. local_debug)
+   !    do_dbg_daily = (do_dbg .or. (istep <= 10*nstep_day)) .and. (mod(istep, nstep_day) == 0)
+
+   !    !---------------------------------------------------------------------
+   !    ! 1) Determine forcing year (supports ycycle)
+   !    !---------------------------------------------------------------------
+   !    modadj = abs((min(0,myear-fyear_init)/ycycle + 1) * ycycle)
+   !    fyr    = fyear_init + mod(myear - fyear_init + modadj, ycycle)
+
+   !    if (fyr /= last_fyr) then
+   !       call AFIM_files(fyr)                 ! updates F_AFIM -> ORAS_YYYY.nc
+   !       last_fyr = fyr
+   !       last_rec_slot(1) = -999999
+   !       last_rec_slot(2) = -999999
+   !       if (my_task == master_task) then
+   !          write(nu_diag,*) subname,' switching forcing year -> ', fyr
+   !          write(nu_diag,*) subname,' F_AFIM = ', trim(F_AFIM)
+   !          call icepack_warnings_flush(nu_diag)
+   !       endif
+   !    endif
+
+   !    !---------------------------------------------------------------------
+   !    ! 2) Determine which two records we need + interpolation coefficients
+   !    !---------------------------------------------------------------------
+   !    dataloc = 2  ! data at end of interval
+
+   !    if (trim(ocn_data_freq) == 'monthly') then
+   !       maxrec = months_per_year
+   !       first_half = (int(mday) < 15) .or. (int(mday) == 15 .and. int(msec) == 0)
+
+   !       if (first_half) then
+   !          rec1 = max(1, min(maxrec, mmonth))
+   !          rec0 = rec1 - 1
+   !          if (rec0 < 1) rec0 = maxrec
+   !          call interp_coeff_monthly(2)
+   !       else
+   !          rec0 = max(1, min(maxrec, mmonth))
+   !          rec1 = rec0 + 1
+   !          if (rec1 > maxrec) rec1 = 1
+   !          call interp_coeff_monthly(1)
+   !       endif
+
+   !    elseif (trim(ocn_data_freq) == 'weekly') then
+   !       maxrec = days_per_year / 7
+   !       rec1   = int( real(yday-1,kind=dbl_kind) / 7._dbl_kind ) + 1
+   !       rec1   = max(1, min(maxrec, rec1))
+   !       rec0   = max(1, rec1-1)
+   !       call interp_coeff(rec1, 2, secday*7._dbl_kind, dataloc)
+
+   !    else
+   !       maxrec = days_per_year
+   !       rec1   = int(yday)
+   !       rec1   = max(1, min(maxrec, rec1))
+   !       rec0   = max(1, rec1-1)
+   !       call interp_coeff(rec1, 2, secday, dataloc)
+   !    endif
+
+   !    !---------------------------------------------------------------------
+   !    ! 3) Read only when needed (record changed)
+   !    !    slot1 holds rec0, slot2 holds rec1.
+   !    !---------------------------------------------------------------------
+   !    need_read_slot1 = (rec0 /= last_rec_slot(1))
+   !    need_read_slot2 = (rec1 /= last_rec_slot(2))
+
+   !    if (need_read_slot1 .or. need_read_slot2) then
+
+   !       if (my_task == master_task) then
+   !          write(nu_diag,*) subname,' reading records rec0/rec1 = ', rec0, rec1
+   !          write(nu_diag,*) subname,' c1intp/c2intp = ', c1intp, c2intp
+   !          write(nu_diag,*) subname,' file = ', trim(F_AFIM)
+   !          call icepack_warnings_flush(nu_diag)
+   !       endif
+
+   !       call ice_open_nc(F_AFIM, fid)
+
+   !       ! --- slot 1 (rec0) ---
+   !       if (need_read_slot1) then
+   !          call ice_read_nc(fid, rec0, 'sst', sst_data(:,:,1,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+   !          call ice_read_nc(fid, rec0, 'sss', sss_data(:,:,1,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+
+   !          ! IMPORTANT: read currents as vectors at NEcorner (matches “working” version)
+   !          call ice_read_nc(fid, rec0, 'u',   uocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+   !          call ice_read_nc(fid, rec0, 'v',   vocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+
+   !          last_rec_slot(1) = rec0
+   !       endif
+
+   !       ! --- slot 2 (rec1) ---
+   !       if (need_read_slot2) then
+   !          if (rec1 == rec0) then
+   !             sst_data (:,:,2,:) = sst_data (:,:,1,:)
+   !             sss_data (:,:,2,:) = sss_data (:,:,1,:)
+   !             uocn_data(:,:,2,:) = uocn_data(:,:,1,:)
+   !             vocn_data(:,:,2,:) = vocn_data(:,:,1,:)
+   !          else
+   !             call ice_read_nc(fid, rec1, 'sst', sst_data(:,:,2,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+   !             call ice_read_nc(fid, rec1, 'sss', sss_data(:,:,2,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+   !             call ice_read_nc(fid, rec1, 'u',   uocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+   !             call ice_read_nc(fid, rec1, 'v',   vocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+   !          endif
+   !          last_rec_slot(2) = rec1
+   !       endif
+
+   !       call ice_close_nc(fid)
+
+   !       ! Raw record stats: only print when we actually read new records
+   !       if ((do_dbg) .and. (my_task == master_task)) then
+   !          write(nu_diag,*) subname,' raw record stats (slot1/slot2; masked by tmask/umask):'
+   !          vmin = global_minval(sst_data(:,:,1,:), distrb_info, tmask); vmax = global_maxval(sst_data(:,:,1,:), distrb_info, tmask)
+   !          write(nu_diag,*) subname,'  sst_data slot1 min/max ', vmin, vmax
+   !          vmin = global_minval(sst_data(:,:,2,:), distrb_info, tmask); vmax = global_maxval(sst_data(:,:,2,:), distrb_info, tmask)
+   !          write(nu_diag,*) subname,'  sst_data slot2 min/max ', vmin, vmax
+   !          vmin = global_minval(sss_data(:,:,1,:), distrb_info, tmask); vmax = global_maxval(sss_data(:,:,1,:), distrb_info, tmask)
+   !          write(nu_diag,*) subname,'  sss_data slot1 min/max ', vmin, vmax
+   !          vmin = global_minval(sss_data(:,:,2,:), distrb_info, tmask); vmax = global_maxval(sss_data(:,:,2,:), distrb_info, tmask)
+   !          write(nu_diag,*) subname,'  sss_data slot2 min/max ', vmin, vmax
+   !          call icepack_warnings_flush(nu_diag)
+   !       endif
+
+   !    endif
+
+   !    !---------------------------------------------------------------------
+   !    ! 4) Apply forcing each timestep
+   !    !---------------------------------------------------------------------
+   !    TT_loc = max(T_T, 1.0e-6_dbl_kind)      ! days, never <= 0
+   !    TS_loc = max(T_S, 1.0e-6_dbl_kind)
+   !    a0_loc = max(a_0, 1.0e-12_dbl_kind)     ! avoid divide-by-zero
+   !    pw_loc = max(p_w, 1.0_dbl_kind)
+
+   !    tauT = max(dt, TT_loc * secday)
+   !    tauS = max(dt, TS_loc * secday)
+   !    facT = min(c1, dt / tauT)
+   !    facS = min(c1, dt / tauS)
+
+   !    if (my_task == master_task) then
+   !       write(nu_diag,*) subname,' T_T=',T_T,' TT_loc=',TT_loc,' tauT(s)=',tauT,' facT=',facT
+   !       write(nu_diag,*) subname,' T_S=',T_S,' TS_loc=',TS_loc,' tauS(s)=',tauS,' facS=',facS
+   !       write(nu_diag,*) subname,' a_0=',a0_loc,' p_w=',pw_loc,' ocn_data_freq=',trim(ocn_data_freq)
+   !       call icepack_warnings_flush(nu_diag)
+   !    endif
+
+   ! !$OMP PARALLEL DO DEFAULT(SHARED) &
+   ! !$OMP PRIVATE(iblk,i,j, sst_tgt,sss_tgt,u_tgt,v_tgt, Tf_loc, sst_sc_floor, a,w,wraw,sst_tgt_eff) &
+   ! !$OMP REDUCTION(+:n_ocn,n_bad_sst,n_bad_sss,n_low_sss,n_bad_uv,n_nonfinite_state)
+   !    do iblk = 1, nblocks
+   !       do j = 1, ny_block
+   !          do i = 1, nx_block
+
+   !             if (hm(i,j,iblk) == c0) then
+   !                ! land
+   !                sst (i,j,iblk) = c0
+   !                sss (i,j,iblk) = c0
+   !                uocn(i,j,iblk) = c0
+   !                vocn(i,j,iblk) = c0
+   !             else
+   !                n_ocn = n_ocn + 1
+
+   !                ! Linear time interpolation between cached records
+   !                sst_tgt = c1intp*sst_data (i,j,1,iblk) + c2intp*sst_data (i,j,2,iblk)
+   !                sss_tgt = c1intp*sss_data (i,j,1,iblk) + c2intp*sss_data (i,j,2,iblk)
+   !                u_tgt   = c1intp*uocn_data(i,j,1,iblk) + c2intp*uocn_data(i,j,2,iblk)
+   !                v_tgt   = c1intp*vocn_data(i,j,1,iblk) + c2intp*vocn_data(i,j,2,iblk)
+
+   !                ! Local freezing point (defensive)
+   !                Tf_loc = Tf(i,j,iblk)
+   !                if (.not. ieee_is_finite(Tf_loc)) Tf_loc = Tf_default
+
+   !                !---------------------------------------------------------
+   !                ! Missing/fill handling
+   !                !   - Treat non-finite SST/SSS as missing
+   !                !   - Treat very low SSS (<=5 psu) as missing/fill (common “0” artefact)
+   !                !   - Cap absurd SST/SSS, and cap extreme currents
+   !                !---------------------------------------------------------
+   !                if ((.not. ieee_is_finite(sss_tgt)) .or. (sss_tgt > sss_hi_thresh) .or. (sss_tgt <= sss_lo_thresh)) then
+   !                   n_bad_sss = n_bad_sss + 1
+   !                   if (sss_tgt <= sss_lo_thresh) n_low_sss = n_low_sss + 1
+   !                   sss_tgt = sss_default
+   !                endif
+
+   !                if ((.not. ieee_is_finite(sst_tgt)) .or. (sst_tgt < sst_lo_thresh) .or. (sst_tgt > sst_hi_thresh)) then
+   !                   n_bad_sst = n_bad_sst + 1
+   !                   sst_tgt   = Tf_loc
+   !                endif
+
+   !                ! If salinity looked like fill, SST is often also not meaningful → pull SST toward freezing
+   !                if (sss_tgt <= sss_lo_thresh + 1.0e-12_dbl_kind) then
+   !                   sst_tgt = Tf_loc
+   !                endif
+
+   !                if ((.not. ieee_is_finite(u_tgt)) .or. (abs(u_tgt) > ispd_thresh)) then
+   !                   n_bad_uv = n_bad_uv + 1
+   !                   u_tgt = c0
+   !                endif
+   !                if ((.not. ieee_is_finite(v_tgt)) .or. (abs(v_tgt) > ispd_thresh)) then
+   !                   n_bad_uv = n_bad_uv + 1
+   !                   v_tgt = c0
+   !                endif
+
+   !                ! Ensure prognostic state is finite before nudging
+   !                if (.not. ieee_is_finite(sst(i,j,iblk))) then
+   !                   sst(i,j,iblk) = sst_tgt
+   !                   n_nonfinite_state = n_nonfinite_state + 1
+   !                endif
+   !                if (.not. ieee_is_finite(sss(i,j,iblk))) then
+   !                   sss(i,j,iblk) = sss_tgt
+   !                   n_nonfinite_state = n_nonfinite_state + 1
+   !                endif
+
+   !                !---------------------------------------------------------
+   !                ! Weight w(aice): 1 in open water; 0 in consolidated ice
+   !                !---------------------------------------------------------
+   !                a = aice(i,j,iblk)
+   !                if (.not. ieee_is_finite(a)) a = c0
+
+   !                wraw = (a0_loc - a) / a0_loc
+   !                w    = min(c1, max(c0, wraw))
+   !                if (pw_loc > c1) w = w**pw_loc
+
+   !                !---------------------------------------------------------
+   !                ! SST target under ice: blend toward freezing point
+   !                !---------------------------------------------------------
+   !                sst_tgt_eff   = w*sst_tgt + (c1 - w)*Tf_loc
+   !                sst(i,j,iblk) = sst(i,j,iblk) + facT*(sst_tgt_eff - sst(i,j,iblk))
+
+   !                ! modest supercooling limiter (do NOT clamp to Tf)
+   !                sst_sc_floor  = Tf_loc - dT_sc_max
+   !                sst(i,j,iblk) = max(sst(i,j,iblk), sst_sc_floor)
+
+   !                !---------------------------------------------------------
+   !                ! SSS: restore mainly in open water (tapered by w)
+   !                !---------------------------------------------------------
+   !                sss(i,j,iblk) = sss(i,j,iblk) + facS*w*(sss_tgt - sss(i,j,iblk))
+
+   !                !---------------------------------------------------------
+   !                ! Currents: accept targets (after guardrails)
+   !                !---------------------------------------------------------
+   !                uocn(i,j,iblk) = u_tgt
+   !                vocn(i,j,iblk) = v_tgt
+
+   !             endif
+   !          enddo
+   !       enddo
+   !    enddo
+   ! !$OMP END PARALLEL DO
+
+   !    ! Update freezing temperature after salinity update
+   !    call ocn_freezing_temperature
+
+   !    !---------------------------------------------------------------------
+   !    ! Diagnostics / prints
+   !    !---------------------------------------------------------------------
+   !    if ((do_dbg_daily) .and. (my_task == master_task)) then
+   !       write(nu_diag,*) subname,' istep=',istep,' yday=',yday,' msec=',msec
+   !       write(nu_diag,*) subname,' counts (MPI-local): ocean=',n_ocn, &
+   !                      ' bad_sst=',n_bad_sst,' bad_sss=',n_bad_sss,' low_sss=',n_low_sss, &
+   !                      ' bad_uv=',n_bad_uv,' nonfinite_state_fixups=',n_nonfinite_state
+
+   !       vmin = global_minval(aice, distrb_info, tmask); vmax = global_maxval(aice, distrb_info, tmask)
+   !       write(nu_diag,*) subname,' aice min/max ', vmin, vmax
+
+   !       vmin = global_minval(sst,  distrb_info, tmask); vmax = global_maxval(sst,  distrb_info, tmask)
+   !       write(nu_diag,*) subname,' sst  min/max ', vmin, vmax
+
+   !       vmin = global_minval(sss,  distrb_info, tmask); vmax = global_maxval(sss,  distrb_info, tmask)
+   !       write(nu_diag,*) subname,' sss  min/max ', vmin, vmax
+
+   !       vmin = global_minval(Tf,   distrb_info, tmask); vmax = global_maxval(Tf,   distrb_info, tmask)
+   !       write(nu_diag,*) subname,' Tf   min/max ', vmin, vmax
+
+   !       call icepack_warnings_flush(nu_diag)
+   !    endif
+
+   ! end subroutine AFIM_data
    subroutine AFIM_data(dt)
+
       use ice_blocks, only            : nx_block, ny_block
       use ice_read_write, only        : ice_read_nc, ice_open_nc, ice_close_nc
       use ice_global_reductions, only : global_minval, global_maxval
@@ -1959,65 +2632,102 @@ subroutine AFIM_data(dt)
       use ice_flux, only              : sss, sst, uocn, vocn, Tf
       use ice_grid, only              : hm, tmask, umask
       use ice_calendar, only          : days_per_year, months_per_year, mmonth, myear, yday, mday, msec
-      use ice_restart_shared, only    : restart
+      use ice_state, only             : aice
+      use, intrinsic :: ieee_arithmetic, only : ieee_is_finite
       implicit none
+
       real(kind=dbl_kind), intent(in) :: dt
-      integer(kind=int_kind)          :: fid
-      integer(kind=int_kind)          :: i, j, iblk
-      integer(kind=int_kind)          :: rec0, rec1, maxrec, dataloc
-      integer(kind=int_kind)          :: fyr, modadj
-      real(kind=dbl_kind)             :: secday
-      real(kind=dbl_kind)             :: sst_tgt, sss_tgt, u_tgt, v_tgt
-      real(kind=dbl_kind)             :: vmin, vmax
-      logical                         :: need_read_slot1, need_read_slot2
-      logical                         :: first_half
-      character(len=*), parameter     :: subname = '(AFIM_data)'
-      ! --- thresholds / sanity clamps (retain your choices) ---
-      real(kind=dbl_kind), parameter  :: sst_thresh      = 54.0_dbl_kind  ! degC
-      real(kind=dbl_kind), parameter  :: sss_high_thresh = 47.0_dbl_kind  ! psu
-      real(kind=dbl_kind), parameter  :: sss_low_thresh  =  5.0_dbl_kind  ! psu
-      real(kind=dbl_kind), parameter  :: ispd_thresh     =  2.5_dbl_kind  ! m/s
-      ! --- cached state (persists across calls) ---
-      integer(kind=int_kind), save    :: last_fyr = -999999
-      integer(kind=int_kind), save    :: last_rec_slot(2) = (/ -999999, -999999 /)  ! slot1, slot2
+
+      character(len=*), parameter :: subname = '(AFIM_data)'
+
+      !----------------------------
+      ! Tunable guards (debug-phase)
+      !----------------------------
+      real(kind=dbl_kind), parameter :: dT_sc_max      = 0.20_dbl_kind
+      real(kind=dbl_kind), parameter :: Tf_default     = -1.8_dbl_kind
+      real(kind=dbl_kind), parameter :: sss_default    = 34.0_dbl_kind
+      real(kind=dbl_kind), parameter :: sss_fill_floor = 20.0_dbl_kind   ! DEBUG: treat SSS<20 as fill in SO
+      real(kind=dbl_kind), parameter :: sss_hi_thresh  = 60.0_dbl_kind
+      real(kind=dbl_kind), parameter :: sst_lo_thresh  = -10.0_dbl_kind
+      real(kind=dbl_kind), parameter :: sst_hi_thresh  =  50.0_dbl_kind
+      real(kind=dbl_kind), parameter :: ispd_thresh    =   2.5_dbl_kind
+
+      integer(kind=int_kind) :: fid, i, j, iblk
+      integer(kind=int_kind) :: rec0, rec1, maxrec, dataloc, fyr, modadj
+      logical                :: need_read_slot1, need_read_slot2, first_half
+
+      real(kind=dbl_kind) :: secday
+      real(kind=dbl_kind) :: sst_tgt, sss_tgt, u_tgt, v_tgt
+      real(kind=dbl_kind) :: Tf_loc, sst_sc_floor
+      real(kind=dbl_kind) :: a, w, wraw, sst_tgt_eff
+      real(kind=dbl_kind) :: tauT, tauS, facT, facS, TT_loc, TS_loc, a0_loc, pw_loc
+      real(kind=dbl_kind) :: vmin, vmax
+
+      integer(kind=int_kind) :: nstep_day, nstep_2hr
+      logical                :: do_early, do_dbg
+
+      integer(kind=int_kind) :: n_ocn, n_bad_sst, n_bad_sss, n_bad_uv, n_nonfinite_state
+
+      integer(kind=int_kind), save :: last_fyr = -999999
+      integer(kind=int_kind), save :: last_rec_slot(2) = (/ -999999, -999999 /)
+
+      n_ocn             = 0
+      n_bad_sst         = 0
+      n_bad_sss         = 0
+      n_bad_uv          = 0
+      n_nonfinite_state = 0
+
       call icepack_query_parameters(secday_out=secday)
       call icepack_warnings_flush(nu_diag)
       if (icepack_warnings_aborted()) call abort_ice(error_message=subname, file=__FILE__, line=__LINE__)
+
+      nstep_day = max(1_int_kind, int(secday/dt + 0.5_dbl_kind))
+      nstep_2hr = max(1_int_kind, int((2.0_dbl_kind*3600.0_dbl_kind)/dt + 0.5_dbl_kind))
+
+      do_early = (istep <= 10)
+      do_dbg   = (debug_forcing .or. local_debug)
+
+      if (my_task == master_task .and. do_early) then
+         write(nu_diag,*) subname,' ENTER istep=',istep,' yday=',yday,' msec=',msec
+         call icepack_warnings_flush(nu_diag)
+      endif
+
       !---------------------------------------------------------------------
-      ! 1) Determine forcing year (supports ycycle logic used elsewhere)
+      ! 1) forcing year
       !---------------------------------------------------------------------
       modadj = abs((min(0,myear-fyear_init)/ycycle + 1) * ycycle)
       fyr    = fyear_init + mod(myear - fyear_init + modadj, ycycle)
+
       if (fyr /= last_fyr) then
-         call AFIM_files(fyr)                 ! updates F_AFIM -> ORAS_YYYY.nc
+         call AFIM_files(fyr)
          last_fyr = fyr
          last_rec_slot(1) = -999999
          last_rec_slot(2) = -999999
          if (my_task == master_task) then
             write(nu_diag,*) subname,' switching forcing year -> ', fyr
             write(nu_diag,*) subname,' F_AFIM = ', trim(F_AFIM)
+            call icepack_warnings_flush(nu_diag)
          endif
       endif
+
       !---------------------------------------------------------------------
-      ! 2) Determine which two records we need (rec0=slot1, rec1=slot2),
-      !    and set interpolation coefficients c1intp/c2intp.
+      ! 2) record selection + coeffs
       !---------------------------------------------------------------------
-      dataloc = 2  ! data located at end of interval (matches your prior usage)
+      dataloc = 2
+
       if (trim(ocn_data_freq) == 'monthly') then
          maxrec = months_per_year
-         ! midpoint is at day 15, 00:00; treat (mday<15) as first half
          first_half = (int(mday) < 15) .or. (int(mday) == 15 .and. int(msec) == 0)
          if (first_half) then
-            ! slot2 = current month, slot1 = previous month (wrap within same file)
             rec1 = max(1, min(maxrec, mmonth))
             rec0 = rec1 - 1
             if (rec0 < 1) rec0 = maxrec
-            call interp_coeff_monthly(2)   ! recslot=2 => first half (per your routine)
-         else ! slot1 = current month, slot2 = next month (wrap within same file)
+            call interp_coeff_monthly(2)
+         else
             rec0 = max(1, min(maxrec, mmonth))
             rec1 = rec0 + 1
             if (rec1 > maxrec) rec1 = 1
-            call interp_coeff_monthly(1)   ! recslot=1 => second half
+            call interp_coeff_monthly(1)
          endif
       elseif (trim(ocn_data_freq) == 'weekly') then
          maxrec = days_per_year / 7
@@ -2025,342 +2735,201 @@ subroutine AFIM_data(dt)
          rec1   = max(1, min(maxrec, rec1))
          rec0   = max(1, rec1-1)
          call interp_coeff(rec1, 2, secday*7._dbl_kind, dataloc)
-      else ! default to daily
+      else
          maxrec = days_per_year
          rec1   = int(yday)
          rec1   = max(1, min(maxrec, rec1))
          rec0   = max(1, rec1-1)
          call interp_coeff(rec1, 2, secday, dataloc)
       endif
+
       !---------------------------------------------------------------------
-      ! 3) Read only when needed (record changed since last call).
-      !    slot1 holds rec0, slot2 holds rec1.
+      ! 3) read when needed
       !---------------------------------------------------------------------
       need_read_slot1 = (rec0 /= last_rec_slot(1))
       need_read_slot2 = (rec1 /= last_rec_slot(2))
+
       if (need_read_slot1 .or. need_read_slot2) then
+
          if (my_task == master_task) then
             write(nu_diag,*) subname,' reading records rec0/rec1 = ', rec0, rec1
             write(nu_diag,*) subname,' c1intp/c2intp = ', c1intp, c2intp
             write(nu_diag,*) subname,' file = ', trim(F_AFIM)
+            call icepack_warnings_flush(nu_diag)
          endif
+
          call ice_open_nc(F_AFIM, fid)
-         ! --- slot 1 (rec0) ---
+
          if (need_read_slot1) then
-            call ice_read_nc(fid, rec0, 'sst', sst_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-            call ice_read_nc(fid, rec0, 'sss', sss_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-            call ice_read_nc(fid, rec0, 'u'  , uocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-            call ice_read_nc(fid, rec0, 'v'  , vocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+            call ice_read_nc(fid, rec0, 'sst', sst_data(:,:,1,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+            call ice_read_nc(fid, rec0, 'sss', sss_data(:,:,1,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+            call ice_read_nc(fid, rec0, 'u',   uocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+            call ice_read_nc(fid, rec0, 'v',   vocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
             last_rec_slot(1) = rec0
          endif
-         ! --- slot 2 (rec1) ---
+
          if (need_read_slot2) then
             if (rec1 == rec0) then
-               ! avoid duplicate reads; just copy slot1 -> slot2
                sst_data (:,:,2,:) = sst_data (:,:,1,:)
                sss_data (:,:,2,:) = sss_data (:,:,1,:)
                uocn_data(:,:,2,:) = uocn_data(:,:,1,:)
                vocn_data(:,:,2,:) = vocn_data(:,:,1,:)
             else
-               call ice_read_nc(fid, rec1, 'sst', sst_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-               call ice_read_nc(fid, rec1, 'sss', sss_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-               call ice_read_nc(fid, rec1, 'u'  , uocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-               call ice_read_nc(fid, rec1, 'v'  , vocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+               call ice_read_nc(fid, rec1, 'sst', sst_data(:,:,2,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+               call ice_read_nc(fid, rec1, 'sss', sss_data(:,:,2,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
+               call ice_read_nc(fid, rec1, 'u',   uocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+               call ice_read_nc(fid, rec1, 'v',   vocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
             endif
             last_rec_slot(2) = rec1
          endif
+
          call ice_close_nc(fid)
+
+         if ((do_dbg) .and. (my_task == master_task)) then
+            write(nu_diag,*) subname,' raw record stats (masked):'
+            vmin = global_minval(sst_data(:,:,1,:), distrb_info, tmask); vmax = global_maxval(sst_data(:,:,1,:), distrb_info, tmask)
+            write(nu_diag,*) subname,'  sst_data slot1 min/max ', vmin, vmax
+            vmin = global_minval(sss_data(:,:,1,:), distrb_info, tmask); vmax = global_maxval(sss_data(:,:,1,:), distrb_info, tmask)
+            write(nu_diag,*) subname,'  sss_data slot1 min/max ', vmin, vmax
+            call icepack_warnings_flush(nu_diag)
+         endif
+
       endif
+
       !---------------------------------------------------------------------
-      ! 4) Apply interpolation each timestep (NO nested OpenMP; no races)
+      ! 4) timescales + factors
       !---------------------------------------------------------------------
-      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(iblk,i,j,sst_tgt,sss_tgt,u_tgt,v_tgt)
+      TT_loc = max(T_T, 1.0e-6_dbl_kind)
+      TS_loc = max(T_S, 1.0e-6_dbl_kind)
+      a0_loc = max(a_0, 1.0e-12_dbl_kind)
+      pw_loc = max(p_w, 1.0_dbl_kind)
+
+      tauT = max(dt, TT_loc * secday)
+      tauS = max(dt, TS_loc * secday)
+      facT = min(c1, dt / tauT)
+      facS = min(c1, dt / tauS)
+
+      if (my_task == master_task .and. istep == 1) then
+         write(nu_diag,*) subname,' T_T=',T_T,' TT_loc=',TT_loc,' tauT(s)=',tauT,' facT=',facT
+         write(nu_diag,*) subname,' T_S=',T_S,' TS_loc=',TS_loc,' tauS(s)=',tauS,' facS=',facS
+         write(nu_diag,*) subname,' a_0=',a0_loc,' p_w=',pw_loc,' ocn_data_freq=',trim(ocn_data_freq)
+         call icepack_warnings_flush(nu_diag)
+      endif
+
+   !$OMP PARALLEL DO DEFAULT(SHARED) &
+   !$OMP PRIVATE(iblk,i,j, sst_tgt,sss_tgt,u_tgt,v_tgt, Tf_loc, sst_sc_floor, a,w,wraw,sst_tgt_eff) &
+   !$OMP REDUCTION(+:n_ocn,n_bad_sst,n_bad_sss,n_bad_uv,n_nonfinite_state)
       do iblk = 1, nblocks
          do j = 1, ny_block
             do i = 1, nx_block
+
                if (hm(i,j,iblk) == c0) then
                   sst (i,j,iblk) = c0
                   sss (i,j,iblk) = c0
                   uocn(i,j,iblk) = c0
                   vocn(i,j,iblk) = c0
-               else ! linear interpolation in time
+               else
+                  n_ocn = n_ocn + 1
+
                   sst_tgt = c1intp*sst_data (i,j,1,iblk) + c2intp*sst_data (i,j,2,iblk)
                   sss_tgt = c1intp*sss_data (i,j,1,iblk) + c2intp*sss_data (i,j,2,iblk)
                   u_tgt   = c1intp*uocn_data(i,j,1,iblk) + c2intp*uocn_data(i,j,2,iblk)
                   v_tgt   = c1intp*vocn_data(i,j,1,iblk) + c2intp*vocn_data(i,j,2,iblk)
-                  ! restore SST if requested (do this every timestep for correct timescale)
-                  if (restore_ocn) then
-                     sst(i,j,iblk) = sst(i,j,iblk) + (sst_tgt - sst(i,j,iblk)) * dt / trest
-                  else
+
+                  Tf_loc = Tf(i,j,iblk)
+                  if (.not. ieee_is_finite(Tf_loc)) Tf_loc = Tf_default
+
+                  ! SSS guard (treat low salinity as fill in SO debug)
+                  if ((.not. ieee_is_finite(sss_tgt)) .or. (sss_tgt < sss_fill_floor) .or. (sss_tgt > sss_hi_thresh)) then
+                     n_bad_sss = n_bad_sss + 1
+                     sss_tgt   = sss_default
+                     ! if SSS was fill-like, SST under ice is usually also untrustworthy
+                     sst_tgt   = Tf_loc
+                  endif
+
+                  ! SST guard
+                  if ((.not. ieee_is_finite(sst_tgt)) .or. (sst_tgt < sst_lo_thresh) .or. (sst_tgt > sst_hi_thresh)) then
+                     n_bad_sst = n_bad_sst + 1
+                     sst_tgt   = Tf_loc
+                  endif
+
+                  ! Currents guard
+                  if ((.not. ieee_is_finite(u_tgt)) .or. (abs(u_tgt) > ispd_thresh)) then
+                     n_bad_uv = n_bad_uv + 1
+                     u_tgt = c0
+                  endif
+                  if ((.not. ieee_is_finite(v_tgt)) .or. (abs(v_tgt) > ispd_thresh)) then
+                     n_bad_uv = n_bad_uv + 1
+                     v_tgt = c0
+                  endif
+
+                  if (.not. ieee_is_finite(sst(i,j,iblk))) then
                      sst(i,j,iblk) = sst_tgt
+                     n_nonfinite_state = n_nonfinite_state + 1
+                  endif
+                  if (.not. ieee_is_finite(sss(i,j,iblk))) then
+                     sss(i,j,iblk) = sss_tgt
+                     n_nonfinite_state = n_nonfinite_state + 1
                   endif
-                  ! direct forcing for SSS + currents (as in your current logic)
-                  sss (i,j,iblk) = sss_tgt
+
+                  a = aice(i,j,iblk)
+                  if (.not. ieee_is_finite(a)) a = c0
+
+                  wraw = (a0_loc - a) / a0_loc
+                  w    = min(c1, max(c0, wraw))
+                  if (pw_loc > c1) w = w**pw_loc
+
+                  sst_tgt_eff   = w*sst_tgt + (c1 - w)*Tf_loc
+                  sst(i,j,iblk) = sst(i,j,iblk) + facT*(sst_tgt_eff - sst(i,j,iblk))
+
+                  sst_sc_floor  = Tf_loc - dT_sc_max
+                  sst(i,j,iblk) = max(sst(i,j,iblk), sst_sc_floor)
+
+                  sss(i,j,iblk) = sss(i,j,iblk) + facS*w*(sss_tgt - sss(i,j,iblk))
+
                   uocn(i,j,iblk) = u_tgt
                   vocn(i,j,iblk) = v_tgt
-                  ! clamps / sanity checks (retain your intent)
-                  sst(i,j,iblk) = max(sst(i,j,iblk), Tf(i,j,iblk))
-                  if (sst(i,j,iblk) > sst_thresh) sst(i,j,iblk) = sst_thresh
-                  if (sss(i,j,iblk) > sss_high_thresh) sss(i,j,iblk) = sss_high_thresh
-                  if (sss(i,j,iblk) < sss_low_thresh ) sss(i,j,iblk) = sss_low_thresh
-                  if (abs(uocn(i,j,iblk)) > ispd_thresh) uocn(i,j,iblk) = c0
-                  if (abs(vocn(i,j,iblk)) > ispd_thresh) vocn(i,j,iblk) = c0
+
                endif
             enddo
          enddo
       enddo
-      !$OMP END PARALLEL DO
+   !$OMP END PARALLEL DO
+
       call ocn_freezing_temperature
-      if (debug_forcing .or. local_debug) then
-         if (my_task == master_task) write(nu_diag,*) subname,' global min/max after update (rec0/rec1): ', rec0, rec1
-         vmin = global_minval(sst ,distrb_info,tmask)
-         vmax = global_maxval(sst ,distrb_info,tmask)
-         if (my_task == master_task) write(nu_diag,*) subname,'  sst ', vmin, vmax
-         vmin = global_minval(sss ,distrb_info,tmask)
-         vmax = global_maxval(sss ,distrb_info,tmask)
-         if (my_task == master_task) write(nu_diag,*) subname,'  sss ', vmin, vmax
-         vmin = global_minval(uocn,distrb_info,umask)
-         vmax = global_maxval(uocn,distrb_info,umask)
-         if (my_task == master_task) write(nu_diag,*) subname,'  uocn', vmin, vmax
-         vmin = global_minval(vocn,distrb_info,umask)
-         vmax = global_maxval(vocn,distrb_info,umask)
-         if (my_task == master_task) write(nu_diag,*) subname,'  vocn', vmin, vmax
+
+      ! “heartbeat” prints: first 10 steps always; then every 2 hours for first 2 days; then daily if debug
+      if (my_task == master_task) then
+         if (do_early .or. (istep <= 2*nstep_day .and. mod(istep,nstep_2hr)==0) .or. ((do_dbg) .and. mod(istep,nstep_day)==0)) then
+            write(nu_diag,*) subname,' istep=',istep,' yday=',yday,' msec=',msec, &
+                           ' ocean=',n_ocn,' bad_sst=',n_bad_sst,' bad_sss=',n_bad_sss, &
+                           ' bad_uv=',n_bad_uv,' state_fixups=',n_nonfinite_state
+            vmin = global_minval(aice, distrb_info, tmask); vmax = global_maxval(aice, distrb_info, tmask)
+            write(nu_diag,*) subname,' aice min/max ', vmin, vmax
+            vmin = global_minval(sst,  distrb_info, tmask); vmax = global_maxval(sst,  distrb_info, tmask)
+            write(nu_diag,*) subname,' sst  min/max ', vmin, vmax
+            vmin = global_minval(sss,  distrb_info, tmask); vmax = global_maxval(sss,  distrb_info, tmask)
+            write(nu_diag,*) subname,' sss  min/max ', vmin, vmax
+            vmin = global_minval(Tf,   distrb_info, tmask); vmax = global_maxval(Tf,   distrb_info, tmask)
+            write(nu_diag,*) subname,' Tf   min/max ', vmin, vmax
+            call icepack_warnings_flush(nu_diag)
+         endif
+      endif
+
+      if (my_task == master_task) then
+         if (mod(istep, 48) == 0) then  ! every model day for dt=1800s
+            write(nu_diag,*) subname,' HEARTBEAT istep=',istep,' yday=',yday,' msec=',msec, &
+                           ' rec0/rec1=',rec0,rec1,' c1intp/c2intp=',c1intp,c2intp
+            call icepack_warnings_flush(nu_diag)
+         endif
+      endif
+
+      if (my_task == master_task .and. do_early) then
+         write(nu_diag,*) subname,' EXIT istep=',istep
+         call icepack_warnings_flush(nu_diag)
       endif
-   end subroutine AFIM_data
 
-!   !=======================================================================
-!   ! dpath2o, Feb.24
-!   subroutine AFIM_init
-!     use ice_blocks, only        : nx_block, ny_block
-!     use ice_domain_size, only   : max_blocks
-!     use ice_calendar, only      : isleap
-!     real(kind=dbl_kind), allocatable, dimension(:,:,:,:,:) :: ocn_frcg
-!     character(len=*), parameter :: subname = '(AFIM_init)'
-!     integer (kind=int_kind)     :: n, m, nrec ! field loop, temporal loop, length of time
-!     integer (kind=int_kind)     :: fid
-!     character(char_len)         :: vname(int(4))  ! variable names to search for in file
-!     data vname /  'sst', 'sss', 'u', 'v' /
-!     real (kind=dbl_kind), dimension (nx_block,ny_block,max_blocks) :: work1
-!     if (trim(ocn_data_freq)=='daily') then
-!        nrec = 365
-!        if (mod(myear,  4) == 0) nrec = 366
-!        if (mod(myear,400) == 0) nrec = 366
-!     elseif (trim(ocn_data_freq)=='weekly') then
-!        nrec = wk_per_yr
-!     elseif (trim(ocn_data_freq)=='monthly') then
-!        nrec = m_per_yr
-!     endif
-!     if (my_task.eq.master_task) write(nu_diag, *) subname, ' fyear : ', fyear
-!     if (my_task.eq.master_task) write(nu_diag, *) subname, ' nrec  : ', nrec
-!     allocate(ocn_frcg(nx_block,ny_block,max_blocks,nfld,nrec))
-!   end subroutine AFIM_init
-
-!   !=======================================================================
-!   ! dpath2o, Feb.24
-!   subroutine AFIM_data(dt)
-!     use ice_blocks, only            : nx_block, ny_block
-!     use ice_read_write, only        : ice_read_nc
-!     use ice_global_reductions, only : global_minval, global_maxval
-!     use ice_domain, only            : distrb_info, nblocks
-!     use ice_flux, only              : sss, sst, uocn, vocn, Tf
-!     use ice_grid, only              : hm, tmask, umask
-!     use ice_calendar, only          : days_per_year, months_per_year, mmonth, myear, isleap
-!     use ice_restart_shared, only    : restart
-!     real(kind=dbl_kind), intent(in) :: dt
-!     integer(kind=int_kind)          :: fid, ncid, i, j, n, lfyear, recnum, maxrec, recslot, dataloc, iblk
-!     real(kind=dbl_kind)             :: secday, eps, tt, sst_min, sst_max, sss_min, sss_max, uocn_min,&
-!                                        uocn_max, vocn_min, vocn_max, vmin, vmax, sst_thresh,&
-!                                        sss_high_thresh, sss_low_thresh, ispd_thresh
-!     character(len=64)               :: fieldname
-!     character(len=20)               :: subname = '(AFIM_data)'
-!     real(kind=dbl_kind), dimension(nx_block, ny_block, max_blocks) :: interp_sst, interp_sss,&
-!                                                                       interp_uocn, interp_vocn,&
-!                                                                       sst_curr, sst_prev, sss_curr,&
-!                                                                       sss_prev, uocn_curr, uocn_prev,&
-!                                                                       vocn_curr, vocn_prev
-!     sst_thresh       = 54.0 !deg.C
-!     sss_high_thresh  = 47.0 !psu
-!     sss_low_thresh   = 5.0  !psu
-!     ispd_thresh      = 2.5  !m/s
-!     ! get the seconds in a day from icepack as well as flush the diagnostics from icepack
-!     call icepack_query_parameters(secday_out=secday)
-!     call icepack_warnings_flush(nu_diag)
-!     if (icepack_warnings_aborted()) call abort_ice(error_message=subname, file=__FILE__, line=__LINE__)
-!     ! SET THE RECORD NUMBER & INTERPOLATION COEFFICIENTS
-!     ! the record number is the time index value which determines which time record to extract from the 'forcing' file
-!     ! we set it each time this sub-routine is called to the corresponding frequency of the ocean forcing
-!     ! monthly :: the current month, mid-month
-!     ! daily   :: the current yearday in the middle of that day
-!     ! weekly  :: every 7th day
-!     recslot = 2 ! 2 = second-half, 1 = first-half
-!     dataloc = 2 ! end of period
-!     if (trim(ocn_data_freq)=='monthly') then
-!         maxrec = months_per_year
-!         recnum = mmonth
-!         call interp_coeff_monthly(recslot-1)
-!     elseif (trim(ocn_data_freq)=='daily') then
-!        maxrec = 365
-!        if (mod(myear,  4) == 0) maxrec = 366
-!        if (mod(myear,400) == 0) maxrec = 366
-!        recnum = int(yday) - int(real(msec,kind=dbl_kind)/secday)
-!        call interp_coeff(recnum, recslot, secday, dataloc)
-!     elseif (trim(ocn_data_freq)=='weekly') then
-!         maxrec = days_per_year/int(7)
-!         recnum = int(yday/7)
-!         if (recnum > maxrec) then
-!             recnum = maxrec
-!         endif
-!         call interp_coeff(recnum, recslot, secday*7, dataloc)
-!     endif
-!     if (my_task.eq.master_task) write(nu_diag, *) subname, ' myear, mmonth            : ', myear, mmonth
-!     if (my_task.eq.master_task) write(nu_diag, *) subname, ' maximum records          : ', maxrec
-!     if (my_task.eq.master_task) write(nu_diag, *) subname, ' current record           : ', recnum
-!     if (my_task.eq.master_task) write(nu_diag, *) subname, ' c1,c2: ', c1intp,c2intp
-!     ! ADVANCE THE YEAR
-!     ! only do so when the model year is greater than the initial year and the first time index
-!     if (myear.gt.fyear_init .and. recnum.eq.1) then
-!        call AFIM_files(myear)
-!     endif
-!     if (my_task.eq.master_task) write(nu_diag, *) subname, ' reading in each ocean forcing field for time record', recnum
-!     ! Open the netCDF file and read SST, SSS, U, V fields for current and next time steps
-!     if (my_task==master_task) write(nu_diag,*) subname, ' F_AFIM (file): ', trim(F_AFIM)
-!     call ice_open_nc(F_AFIM, fid)
-!     ! Read SST for current and next time step
-!     call ice_read_nc(fid, recnum, 'sst', sst_curr, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!     if (recnum>1) then
-!        call ice_read_nc(fid, recnum - 1, 'sst', sst_prev, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!     endif
-!     ! Read SSS for current and next time step
-!     call ice_read_nc(fid, recnum, 'sss', sss_curr, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!     if (recnum>1) then
-!        call ice_read_nc(fid, recnum - 1, 'sss', sss_prev, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!     endif
-!     ! Read U and V for current and next time step
-!     ! call ice_read_nc(fid, recnum, 'u', uocn_curr, debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
-!     call ice_read_nc(fid, recnum, 'u', uocn_curr, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!     ! call ice_read_nc(fid, recnum, 'v', vocn_curr, debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
-!     call ice_read_nc(fid, recnum, 'v', vocn_curr, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!     if (recnum>1) then
-!        ! call ice_read_nc(fid, recnum - 1, 'u', uocn_prev, debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
-!        call ice_read_nc(fid, recnum - 1, 'u', uocn_prev, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!        ! call ice_read_nc(fid, recnum - 1, 'v', vocn_prev, debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
-!        call ice_read_nc(fid, recnum - 1, 'v', vocn_prev, debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-!     endif
-!     call ice_close_nc(fid)
-! !$OMP PARALLEL DO PRIVATE(iblk, j, i) SHARED(sst_data, sss_data, uocn_data, vocn_data, interp_sst, interp_sss, interp_uocn, interp_vocn, sst_curr, sst_prev, sss_curr, sss_prev, uocn_curr, uocn_prev, vocn_curr, vocn_prev, sst, sss, uocn, vocn, hm, c1, c0, Tf, dt, trest)
-!     do iblk = 1, nblocks
-!        ! Interpolate and assign SST data
-!        if (recnum>1) then
-!           sst_data(:,:,1,iblk) = sst_prev(:,:,iblk)
-!           sst_data(:,:,2,iblk) = sst_curr(:,:,iblk)
-!        else
-!           sst_data(:,:,1,iblk) = sst_curr(:,:,iblk)
-!           sst_data(:,:,2,iblk) = sst_curr(:,:,iblk)
-!        endif
-!        call interpolate_data(sst_data, interp_sst)
-!        ! 'RESTORE' (ADDITIONAL SMOOTHING) THE SST VALUES BASED ON A PERIOD OF TIME
-!        if (restore_ocn) then
-!           do j = 1, ny_block
-!              do i = 1, nx_block
-!                 sst(i, j, iblk) = sst(i, j, iblk) + (interp_sst(i, j, iblk) - sst(i, j, iblk)) * dt / trest
-!              enddo
-!           enddo
-!        endif
-!        ! Interpolate and assign SSS data
-!        if (recnum>1) then
-!           sss_data(:,:,1,iblk) = sss_prev(:,:,iblk)
-!           sss_data(:,:,2,iblk) = sss_curr(:,:,iblk)
-!        else
-!           sss_data(:,:,1,iblk) = sss_curr(:,:,iblk)
-!           sss_data(:,:,2,iblk) = sss_curr(:,:,iblk)
-!        endif
-!        call interpolate_data(sss_data, interp_sss)
-!        do j = 1, ny_block
-!           do i = 1, nx_block
-!              if (hm(i, j, iblk) == c1) then
-!                 sss(i, j, iblk) = interp_sss(i, j, iblk)
-!              endif
-!           enddo
-!        enddo
-!        ! Interpolate and assign UOCN data
-!        if (recnum>1) then
-!           uocn_data(:,:,1,iblk) = uocn_prev(:,:,iblk)
-!           uocn_data(:,:,2,iblk) = uocn_curr(:,:,iblk)
-!        else
-!           uocn_data(:,:,1,iblk) = uocn_curr(:,:,iblk)
-!           uocn_data(:,:,2,iblk) = uocn_curr(:,:,iblk)
-!        endif
-!        call interpolate_data(uocn_data, interp_uocn)
-!        do j = 1, ny_block
-!           do i = 1, nx_block
-!              if (hm(i, j, iblk) == c1) then
-!                 uocn(i, j, iblk) = interp_uocn(i, j, iblk)
-!              endif
-!           enddo
-!        enddo
-!        ! Interpolate and assign VOCN data
-!        if (recnum>1) then
-!           vocn_data(:,:,1,iblk) = vocn_prev(:,:,iblk)
-!           vocn_data(:,:,2,iblk) = vocn_curr(:,:,iblk)
-!        else
-!           vocn_data(:,:,1,iblk) = vocn_curr(:,:,iblk)
-!           vocn_data(:,:,2,iblk) = vocn_curr(:,:,iblk)
-!        endif
-!        call interpolate_data(vocn_data, interp_vocn)
-!        do j = 1, ny_block
-!           do i = 1, nx_block
-!              if (hm(i, j, iblk) == c1) then
-!                 vocn(i, j, iblk) = interp_vocn(i, j, iblk)
-!              endif
-!           enddo
-!        enddo
-!     enddo
-! !$OMP END PARALLEL DO
-!     !$OMP PARALLEL DO PRIVATE(iblk, j, i) SHARED(sst, sss, uocn, vocn, hm, c1, c0, Tf, dt, trest)
-!     do iblk = 1, nblocks
-!        do j = 1, ny_block
-!           do i = 1, nx_block
-!              if (hm(i,j,iblk) == c0) then
-!                 sst (i,j,iblk) = c0
-!                 sss (i,j,iblk) = c0
-!                 uocn(i,j,iblk) = c0
-!                 vocn(i,j,iblk) = c0
-!              else
-!                 sst(i,j,iblk) = max(sst(i,j,iblk), Tf(i,j,iblk))
-!                 if (sst(i,j,iblk) > sst_thresh) then
-!                    sst(i,j,iblk) = sst_thresh
-!                 endif
-!                 sss(i,j,iblk) = max(sss(i,j,iblk), c0)
-!                 if (sss(i, j, iblk) > sss_high_thresh) then
-!                    sss(i,j,iblk) = sss_high_thresh
-!                 endif
-!                 if (sss(i, j, iblk) < sss_low_thresh) then
-!                    sss(i,j,iblk) = sss_low_thresh
-!                 endif
-!                 if (ABS(uocn(i, j, iblk)) > ispd_thresh) uocn(i, j, iblk) = c0
-!                 if (ABS(vocn(i, j, iblk)) > ispd_thresh) vocn(i, j, iblk) = c0
-!              endif
-!           enddo
-!        enddo
-!     enddo
-!     !$OMP END PARALLEL DO
-!     call ocn_freezing_temperature
-!     if (debug_forcing .or. local_debug) then
-!        if (my_task.eq.master_task) write (nu_diag,*) subname,' AFIM global min max for forcing time record index: ', recnum
-!        vmin = global_minval(sst,distrb_info,tmask)
-!        vmax = global_maxval(sst,distrb_info,tmask)
-!        if (my_task.eq.master_task) write (nu_diag,*) subname,'  sst',vmin,vmax
-!        vmin = global_minval(sss,distrb_info,tmask)
-!        vmax = global_maxval(sss,distrb_info,tmask)
-!        if (my_task.eq.master_task) write (nu_diag,*) subname,'  sss',vmin,vmax
-!        vmin =global_minval(uocn,distrb_info,umask)
-!        vmax =global_maxval(uocn,distrb_info,umask)
-!        if (my_task.eq.master_task) write (nu_diag,*) subname,'  uocn',vmin,vmax
-!        vmin = global_minval(vocn,distrb_info,umask)
-!        vmax = global_maxval(vocn,distrb_info,umask)
-!        if (my_task.eq.master_task) write (nu_diag,*) subname,'  vocn',vmin,vmax
-!     endif
-!   end subroutine AFIM_data
+   end subroutine AFIM_data
 
   !=======================================================================
   subroutine compute_shortwave(nx_block, ny_block, ilo, ihi, jlo, jhi, TLON, TLAT, hm, Qa, cldf, fsw)
diff --git a/cicecore/cicedyn/general/ice_init.F90 b/cicecore/cicedyn/general/ice_init.F90
index a826611..cc9ec55 100644
--- a/cicecore/cicedyn/general/ice_init.F90
+++ b/cicecore/cicedyn/general/ice_init.F90
@@ -99,6 +99,7 @@ subroutine input_data
           atm_data_format, ocn_data_format, atm_data_version, &
           bgc_data_type, &
           ocn_data_type, ocn_data_freq, ocn_data_dir, wave_spec_file,  &
+          hmix_0, T_T, T_S, a_0, p_w, &
           oceanmixed_file, restore_ocn, trestore, &
           ice_data_type, ice_data_conc, ice_data_dist, &
           snw_filename, &
@@ -120,13 +121,13 @@ subroutine input_data
           ndte, kdyn, revised_evp, yield_curve, &
           evp_algorithm, visc_method,     &
           seabed_stress, seabed_stress_method, &
-          boundary_condition, &
           k1, k2, alphab, threshold_hw, Ktens,  &
           e_yieldcurve, e_plasticpot, coriolis, &
           ssh_stress, kridge, brlx, arlx,       &
           deltaminEVP, deltaminVP, capping,     &
           elasticDamp, dyn_area_min, dyn_mass_min, &
-          coastal_drag, boundary_condition, coastal_drag_stress_factor, Cs, u0
+          lateral_drag, boundary_condition, lateral_drag_stress_factor, &
+          Cs, Cq, u_cap, C_L, u0, form_func
       use ice_dyn_vp, only: &
           maxits_nonlin, precond, dim_fgmres, dim_pgmres, maxits_fgmres, &
           maxits_pgmres, monitor_nonlin, monitor_fgmres, &
@@ -249,7 +250,7 @@ subroutine input_data
 
 
       namelist /dynamics_nml/ &
-        boundary_condition, coastal_drag, Cs, u0,                       &
+        boundary_condition, lateral_drag, Cs, Cq, u_cap, C_L, form_func, u0,   &
         kdyn,           ndte,           revised_evp,    yield_curve,    &
         evp_algorithm,  elasticDamp,                                    &
         brlx,           arlx,           ssh_stress,                     &
@@ -300,7 +301,8 @@ subroutine input_data
         atm_data_dir,   ocn_data_dir,    bgc_data_dir,                  &
         atm_data_format, ocn_data_format, rotate_wind,                  &
         oceanmixed_file, atm_data_version,semi_implicit_Tsfc,           &
-        vapor_flux_correction
+        vapor_flux_correction, &
+        hmix_0, T_T, T_S, a_0, p_w
 
       !-----------------------------------------------------------------
       ! default values
@@ -421,8 +423,12 @@ subroutine input_data
 
       ! DYNAMICS
       boundary_condition    = 'no_slip'       ! 'no_slip' (Dirchlet) or 'free_slip' (Neumann); boundary conditions
-      coastal_drag          = .false.         ! if true, enable coastal drag parameterisation for landfast ice
+      lateral_drag          = .false.         ! if true, enable lateral drag parameterisation for landfast ice
+      form_func             = 'static'        ! 'static', 'quad', 'sum', 'linear'
       Cs                    = 1.0e-4_dbl_kind ! see Liu et al. (2022) section 3.3
+      Cq                    = 1.0_dbl_kind    ! see Liu et al. (2022) section 3.3
+      u_cap                 = 0.0_dbl_kind    
+      C_L                   = 0.0_dbl_kind    ! linear form function scaling coeficient (unitless)
       u0                    = 5.0e-4_dbl_kind ! see Lemieux et al. (2015) section 6
       kdyn                  = 1               ! type of dynamics (-1, 0 = off, 1 = evp, 2 = eap, 3 = vp)
       ndtd                  = 1               ! dynamic time steps per thermodynamic time step
@@ -587,6 +593,11 @@ subroutine input_data
       bgc_data_dir    = 'unknown_bgc_data_dir'
       ocn_data_type   = 'default'
       ocn_data_freq   = 'daily'
+      hmix_0          = 60
+      T_T             = 1
+      T_S             = 1
+      a_0             = 0.15
+      p_w             = 1
       ocn_data_dir    = 'unknown_ocn_data_dir'
       oceanmixed_file = 'unknown_oceanmixed_file' ! ocean forcing data
       restore_ocn     = .false.   ! restore sst if true
@@ -1044,8 +1055,12 @@ subroutine input_data
       call broadcast_scalar(kitd,                 master_task)
       call broadcast_scalar(kcatbound,            master_task)
       call broadcast_scalar(boundary_condition,   master_task)
-      call broadcast_scalar(coastal_drag,         master_task)
+      call broadcast_scalar(form_func,            master_task)
+      call broadcast_scalar(lateral_drag,         master_task)
       call broadcast_scalar(Cs,                   master_task)
+      call broadcast_scalar(Cq,                   master_task)
+      call broadcast_scalar(u_cap,                master_task)
+      call broadcast_scalar(C_L,                  master_task)
       call broadcast_scalar(u0,                   master_task)
       call broadcast_scalar(kdyn,                 master_task)
       call broadcast_scalar(ndtd,                 master_task)
@@ -1195,6 +1210,11 @@ subroutine input_data
       call broadcast_scalar(bgc_data_dir,         master_task)
       call broadcast_scalar(ocn_data_type,        master_task)
       call broadcast_scalar(ocn_data_freq,        master_task)
+      call broadcast_scalar(hmix_0,               master_task)
+      call broadcast_scalar(T_T,                  master_task)
+      call broadcast_scalar(T_S,                  master_task)
+      call broadcast_scalar(a_0,                  master_task)
+      call broadcast_scalar(p_w,                  master_task)
       call broadcast_scalar(ocn_data_dir,         master_task)
       call broadcast_scalar(oceanmixed_file,      master_task)
       call broadcast_scalar(restore_ocn,          master_task)
@@ -1493,6 +1513,14 @@ subroutine input_data
             endif
             abort_list = trim(abort_list)//":44"
          endif
+         if (form_func /= 'static' .and. form_func /= 'quad' .and. form_func /= 'quad_cap' &
+            .and. form_func /= 'sum' .and. form_func /= 'sum_quad_cap' .and. form_func /= 'linear') then
+            if (my_task == master_task) then
+               write(nu_diag,*) subname//' ERROR: invalid lateral drag form function scheme'
+               write(nu_diag,*) subname//' ERROR: form_func should be: static, quad, sum or linear'
+            endif
+            abort_list = trim(abort_list)//":44"
+         endif
          if (kdyn > 1 .or. (kdyn == 1 .and. evp_algorithm /= 'standard_2d')) then
             if (my_task == master_task) then
               write(nu_diag,*) subname//' ERROR: grid_ice = C | CD only supported with kdyn=1 and evp_algorithm=standard_2d'
@@ -2104,6 +2132,9 @@ subroutine input_data
                if (grid_ice == 'C' .or. grid_ice == 'CD') then
                   write(nu_diag,1030) ' boundary_condition = ', trim(boundary_condition),' : horizontal boundary condition'
                endif
+               if (grid_ice == 'C' .or. grid_ice == 'CD' .and. lateral_drag) then
+                  write(nu_diag,1030) ' form_func = ', trim(form_func)
+               endif
                if (revised_evp) then
                   tmpstr2 = ' : revised EVP formulation used'
                   write(nu_diag,1002) ' arlx             = ', arlx, ' : stress equation factor alpha'
@@ -2386,6 +2417,11 @@ subroutine input_data
             write(nu_diag,*) '     WARNING: ocean mixed layer ON'
             write(nu_diag,*) '     WARNING: will impact ocean forcing interaction'
             write(nu_diag,*) '     WARNING: coupled forcing will be modified by mixed layer routine'
+            write(nu_diag,1002) '  hmix_0 = ', hmix_0
+            write(nu_diag,1002) '     T_T = ', T_T
+            write(nu_diag,1002) '     T_S = ', T_S
+            write(nu_diag,1002) '     a_0 = ', a_0
+            write(nu_diag,1002) '     p_w = ', p_w
          endif
          write(nu_diag,1030) ' saltflux_option  = ', trim(saltflux_option)
          if (trim(saltflux_option) == 'constant') then
diff --git a/cicecore/cicedyn/infrastructure/ice_grid.F90 b/cicecore/cicedyn/infrastructure/ice_grid.F90
index f61b4b3..6bf11f8 100644
--- a/cicecore/cicedyn/infrastructure/ice_grid.F90
+++ b/cicecore/cicedyn/infrastructure/ice_grid.F90
@@ -256,8 +256,8 @@ subroutine alloc_grid
          umaskCD  (nx_block,ny_block,max_blocks), & ! land/boundary mask, velocity (U-cell)
          nmask    (nx_block,ny_block,max_blocks), & ! land/boundary mask (N-cell)
          emask    (nx_block,ny_block,max_blocks), & ! land/boundary mask (E-cell)
-         F2N      (nx_block,ny_block,max_blocks), & ! coastal drag form factors (N-cell)
-         F2E      (nx_block,ny_block,max_blocks), & ! coastal drag form factors (E-cell)
+         F2N      (nx_block,ny_block,max_blocks), & ! lateral drag form factors (N-cell)
+         F2E      (nx_block,ny_block,max_blocks), & ! lateral drag form factors (E-cell)
          opmask   (nx_block,ny_block,max_blocks), & ! land/boundary orphan mask (atm ocean/ice cell)
          lmask_n  (nx_block,ny_block,max_blocks), & ! northern hemisphere mask
          lmask_s  (nx_block,ny_block,max_blocks), & ! southern hemisphere mask
-- 
2.43.7

