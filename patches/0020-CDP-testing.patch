From b96c5569a28c635889e8559f37384a148317dc20 Mon Sep 17 00:00:00 2001
From: dpath2o <dpath2o@mac.com>
Date: Tue, 28 Oct 2025 11:55:49 +1100
Subject: [PATCH 20/34] CDP testing

---
 cicecore/cicedyn/dynamics/ice_dyn_evp.F90    | 207 +++++--------------
 cicecore/cicedyn/dynamics/ice_dyn_shared.F90 | 147 ++++++++-----
 cicecore/cicedyn/general/ice_init.F90        |   4 +-
 cicecore/cicedyn/infrastructure/ice_grid.F90 |  16 +-
 4 files changed, 152 insertions(+), 222 deletions(-)

diff --git a/cicecore/cicedyn/dynamics/ice_dyn_evp.F90 b/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
index d19c920..c46604a 100644
--- a/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
+++ b/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
@@ -130,10 +130,10 @@ subroutine init_evp
       use ice_domain_size, only: max_blocks
       use ice_domain, only: nblocks, blocks_ice
       use ice_grid, only: grid_ice, dyT, dxT, uarear, tmask, G_HTE, G_HTN, dxN, dyE, &
-         build_F2_form_factors_cgrid
+         build_F2_form_factors_cgrid, F2E, F2N   ! <- this is the only source of truth
       use ice_calendar, only: dt_dyn
       use ice_dyn_shared, only: init_dyn_shared, evp_algorithm, &
-         iceEmask, iceNmask, coastal_drag, create_form_factors, F2E, F2N, cdp_ff_built
+         iceEmask, iceNmask, coastal_drag, create_form_factors
       use ice_dyn_evp1d, only: dyn_evp1d_init
 
 !allocate c and cd grid var. Follow structucre of eap
@@ -156,23 +156,6 @@ subroutine init_evp
       if (coastal_drag .and. create_form_factors) then
          call build_F2_form_factors_cgrid(test_case=.true.)   ! perimeter fallback for your 12Ã—12 ocean box
       endif
-      ! if (coastal_drag .and. create_form_factors) then
-      !    ! do iblk = 1, nblocks
-      !    !    this_block = get_block(blocks_ice(iblk), iblk)
-      !    !    ilo = this_block%ilo;  ihi = this_block%ihi
-      !    !    jlo = this_block%jlo;  jhi = this_block%jhi
-      !    !    do j = jlo, jhi
-      !    !       do i = ilo, ihi
-      !    !          iceEmask(i,j,iblk) = tmask(i,j,iblk) .or. tmask(i+1,j,iblk)
-      !    !          iceNmask(i,j,iblk) = tmask(i,j,iblk) .or. tmask(i,j+1,iblk)
-      !    !       enddo
-      !    !    enddo
-      !    ! enddo
-      !    if (.not. allocated(F2E)) allocate(F2E(nx_block,ny_block,max_blocks))
-      !    if (.not. allocated(F2N)) allocate(F2N(nx_block,ny_block,max_blocks))
-      !    call build_F2_form_factors_cgrid(F2E, F2N, test_case=.true.)
-      !    !call build_F2_form_factors_cgrid()
-      ! endif
 
       if (evp_algorithm == "shared_mem_1d" ) then
          call dyn_evp1d_init
@@ -307,8 +290,8 @@ subroutine evp (dt)
       use ice_grid, only: tmask, umask, umaskCD, nmask, emask, uvm, epm, npm, &
           dxE, dxN, dxT, dxU, dyE, dyN, dyT, dyU, &
           tarear, uarear, earear, narear, grid_average_X2Y, uarea, &
-          grid_ice, grid_atm_dynu, grid_atm_dynv, grid_ocn_dynu, grid_ocn_dynv!, &
-          !F2E, F2N
+          grid_ice, grid_atm_dynu, grid_atm_dynv, grid_ocn_dynu, grid_ocn_dynv, &
+          F2E, F2N
       use ice_state, only: aice, aiU, vice, vsno, uvel, vvel, uvelN, vvelN, &
           uvelE, vvelE, divu, shear, vort, &
           aice_init, aice0, aicen, vicen, strength
@@ -318,8 +301,7 @@ subroutine evp (dt)
           DminTarea, visc_method, deformations, deformationsC_T, deformationsCD_T, &
           strain_rates_U_no_slip, strain_rates_U_free_slip, dxhy, dyhx, cxp, cyp, cxm, cym, &
           iceTmask, iceUmask, iceEmask, iceNmask, &
-          dyn_haloUpdate, fld2, fld3, fld4, &
-          F2E, F2N, cdp_ff_built
+          dyn_haloUpdate, fld2, fld3, fld4
       use ice_dyn_evp1d, only: dyn_evp1d_run
 
       real (kind=dbl_kind), intent(in) :: &
@@ -595,14 +577,6 @@ subroutine evp (dt)
             jlo = this_block%jlo
             jhi = this_block%jhi
 
-            ! ! coastal drag parameterisation prepartion
-            ! do j = jlo, jhi
-            !    do i = ilo, ihi
-            !       emass(i,j,iblk) = 0.5d0 * ( tmass(i,j,iblk) + tmass(i+1,j  ,iblk) )
-            !       nmass(i,j,iblk) = 0.5d0 * ( tmass(i,j,iblk) + tmass(i  ,j+1,iblk) )
-            !    enddo
-            ! enddo
-
             call dyn_prep2 (nx_block,             ny_block,             &
                             ilo, ihi,             jlo, jhi,             &
                             icellT        (iblk), icellU        (iblk), &
@@ -821,48 +795,23 @@ subroutine evp (dt)
       !-----------------------------------------------------------------
       ! coastal drag function KuE/N
       !-----------------------------------------------------------------
+      
       if (coastal_drag) then
          if (grid_ice == "C") then
-            ! --- Diagnostics at end of subcycling ---------------------------------
-            nE = count(epm > c0)
-            nN = count(npm > c0)
-            nU = count(uvm > c0)
-            ! E-faces (AT CDP CALL stepu_C)
-            write(nu_diag,9000) 'AT CDP CAL F2E  min/max/avg =', &
-               minval(F2E , mask=epm>c0),  maxval(F2E , mask=epm>c0),  &
-               sum(F2E , mask=epm>c0)/real(max(1,nE),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuE  min/max/avg =', &
-               minval(KuE , mask=epm>c0),  maxval(KuE , mask=epm>c0),  &
-               sum(KuE , mask=epm>c0)/real(max(1,nE),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuxE min/max/avg =', &
-               minval(KuxE, mask=epm>c0),  maxval(KuxE, mask=epm>c0),  &
-               sum(KuxE, mask=epm>c0)/real(max(1,nE),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuyE min/max/avg =', &
-               minval(KuyE, mask=epm>c0),  maxval(KuyE, mask=epm>c0),  &
-               sum(KuyE, mask=epm>c0)/real(max(1,nE),dbl_kind)
-            ! N-faces (AT CDP CALL stepv_C)
-            write(nu_diag,9000) 'AT CDP CALL F2N  min/max/avg =', &
-               minval(F2N , mask=npm>c0),  maxval(F2N , mask=npm>c0),  &
-               sum(F2N , mask=npm>c0)/real(max(1,nN),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuN  min/max/avg =', &
-               minval(KuN , mask=npm>c0),  maxval(KuN , mask=npm>c0),  &
-               sum(KuN , mask=npm>c0)/real(max(1,nN),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuxN min/max/avg =', &
-               minval(KuxN, mask=npm>c0),  maxval(KuxN, mask=npm>c0),  &
-               sum(KuxN, mask=npm>c0)/real(max(1,nN),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuyN min/max/avg =', &
-               minval(KuyN, mask=npm>c0),  maxval(KuyN, mask=npm>c0),  &
-               sum(KuyN, mask=npm>c0)/real(max(1,nN),dbl_kind)
-            ! U-corners (AT CDP CALL stressC_U / U-averaging)
-            write(nu_diag,9000) 'AT CDP CALL KuU  min/max/avg =', &
-               minval(KuU , mask=uvm>c0),  maxval(KuU , mask=uvm>c0),  &
-               sum(KuU , mask=uvm>c0)/real(max(1,nU),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuxU min/max/avg =', &
-               minval(KuxU, mask=uvm>c0),  maxval(KuxU, mask=uvm>c0),  &
-               sum(KuxU, mask=uvm>c0)/real(max(1,nU),dbl_kind)
-            write(nu_diag,9000) 'AT CDP CALL KuyU min/max/avg =', &
-               minval(KuyU, mask=uvm>c0),  maxval(KuyU, mask=uvm>c0),  &
-               sum(KuyU, mask=uvm>c0)/real(max(1,nU),dbl_kind)
+            nE = count(F2E /= c0)
+            nN = count(F2N /= c0)
+            write(nu_diag,9000) 'before CDP F2E min/max/avg =', &
+               minval(F2E, mask=F2E/=c0), maxval(F2E, mask=F2E/=c0), &
+               sum(F2E, mask=F2E/=c0)/real(max(1,nE), dbl_kind)
+            write(nu_diag,9000) 'before CDP F2N min/max/avg =', &
+               minval(F2N, mask=F2N/=c0), maxval(F2N, mask=F2N/=c0), &
+               sum(F2N, mask=F2N/=c0)/real(max(1,nN), dbl_kind)
+            write(nu_diag,9000) 'before CDP CALL KuE min/max/avg =', &
+               minval(KuE, mask=KuE/=c0), maxval(KuE, mask=KuE/=c0), &
+               sum(KuE, mask=KuE/=c0)/real(max(1,nE), dbl_kind)
+            write(nu_diag,9000) 'before CDP CALL KuN min/max/avg =', &
+               minval(KuN, mask=F2N/=c0), maxval(KuN, mask=KuN/=c0), &
+               sum(KuN, mask=KuN/=c0)/real(max(1,nN), dbl_kind)
             9000 format(a,3(1pe16.8,1x))
             ! ----------------------------------------------------------------------
             !$OMP PARALLEL DO PRIVATE(iblk) SCHEDULE(runtime)
@@ -881,6 +830,18 @@ subroutine evp (dt)
                                                F2N(:,:,iblk)                         )
             enddo
             !$OMP END PARALLEL DO
+            write(nu_diag,9000) 'after CDP CALL F2E min/max/avg =', &
+               minval(F2E, mask=F2E/=c0), maxval(F2E, mask=F2E/=c0), &
+               sum(F2E, mask=F2E/=c0)/real(max(1,nE), dbl_kind)
+            write(nu_diag,9000) 'after CDP CALL F2N min/max/avg =', &
+               minval(F2N, mask=F2N/=c0), maxval(F2N, mask=F2N/=c0), &
+               sum(F2N, mask=F2N/=c0)/real(max(1,nN), dbl_kind)
+            write(nu_diag,9000) 'after CDP CALL KuE min/max/avg =', &
+               minval(KuE, mask=KuE/=c0), maxval(KuE, mask=KuE/=c0), &
+               sum(KuE, mask=KuE/=c0)/real(max(1,nE), dbl_kind)
+            write(nu_diag,9000) 'after CDP CALL KuN min/max/avg =', &
+               minval(KuN, mask=KuN/=c0), maxval(KuN, mask=KuN/=c0), &
+               sum(KuN, mask=KuN/=c0)/real(max(1,nN), dbl_kind)
          endif
       endif
 
@@ -1091,50 +1052,6 @@ subroutine evp (dt)
             enddo  ! iblk
             !$OMP END PARALLEL DO
 
-            ! --- Diagnostics at end of subcycling ---------------------------------
-            if (ksub == ndte) then
-               nE = count(epm > c0)
-               nN = count(npm > c0)
-               nU = count(uvm > c0)
-               ! E-faces (BEFORE stepu_C)
-               write(nu_diag,9000) 'BEFORE stepu_C  F2E  min/max/avg =', &
-                  minval(F2E , mask=epm>c0),  maxval(F2E , mask=epm>c0),  &
-                  sum(F2E , mask=epm>c0)/real(max(1,nE),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stepu_C  KuE  min/max/avg =', &
-                  minval(KuE , mask=epm>c0),  maxval(KuE , mask=epm>c0),  &
-                  sum(KuE , mask=epm>c0)/real(max(1,nE),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stepu_C  KuxE min/max/avg =', &
-                  minval(KuxE, mask=epm>c0),  maxval(KuxE, mask=epm>c0),  &
-                  sum(KuxE, mask=epm>c0)/real(max(1,nE),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stepu_C  KuyE min/max/avg =', &
-                  minval(KuyE, mask=epm>c0),  maxval(KuyE, mask=epm>c0),  &
-                  sum(KuyE, mask=epm>c0)/real(max(1,nE),dbl_kind)
-               ! N-faces (BEFORE stepv_C)
-               write(nu_diag,9000) 'BEFORE stepv_C  F2N  min/max/avg =', &
-                  minval(F2N , mask=npm>c0),  maxval(F2N , mask=npm>c0),  &
-                  sum(F2N , mask=npm>c0)/real(max(1,nN),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stepv_C  KuN  min/max/avg =', &
-                  minval(KuN , mask=npm>c0),  maxval(KuN , mask=npm>c0),  &
-                  sum(KuN , mask=npm>c0)/real(max(1,nN),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stepv_C  KuxN min/max/avg =', &
-                  minval(KuxN, mask=npm>c0),  maxval(KuxN, mask=npm>c0),  &
-                  sum(KuxN, mask=npm>c0)/real(max(1,nN),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stepv_C  KuyN min/max/avg =', &
-                  minval(KuyN, mask=npm>c0),  maxval(KuyN, mask=npm>c0),  &
-                  sum(KuyN, mask=npm>c0)/real(max(1,nN),dbl_kind)
-               ! U-corners (BEFORE stressC_U / U-averaging)
-               write(nu_diag,9000) 'BEFORE stressC_U KuU  min/max/avg =', &
-                  minval(KuU , mask=uvm>c0),  maxval(KuU , mask=uvm>c0),  &
-                  sum(KuU , mask=uvm>c0)/real(max(1,nU),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stressC_U KuxU min/max/avg =', &
-                  minval(KuxU, mask=uvm>c0),  maxval(KuxU, mask=uvm>c0),  &
-                  sum(KuxU, mask=uvm>c0)/real(max(1,nU),dbl_kind)
-               write(nu_diag,9000) 'BEFORE stressC_U KuyU min/max/avg =', &
-                  minval(KuyU, mask=uvm>c0),  maxval(KuyU, mask=uvm>c0),  &
-                  sum(KuyU, mask=uvm>c0)/real(max(1,nU),dbl_kind)
-            end if
-            ! ----------------------------------------------------------------------
-
             ! calls ice_haloUpdate, controls bundles and masks
             call dyn_haloUpdate (halo_info,          halo_info_mask,    &
                                  field_loc_NEcorner, field_type_scalar, &
@@ -1237,55 +1154,33 @@ subroutine evp (dt)
                               vvelN_init(:,:,iblk),                       &
                               uvelN     (:,:,iblk), vvelN     (:,:,iblk), &
                               TbN       (:,:,iblk),                       &
-                              KuxN      (:,:,iblk), KuN       (:,:,iblk))
+                              KuyN      (:,:,iblk), KuN       (:,:,iblk))
             enddo
             !$OMP END PARALLEL DO
 
             ! --- Diagnostics at end of subcycling ---------------------------------
             if (ksub == ndte) then
-               nE = count(epm > c0)
-               nN = count(npm > c0)
-               nU = count(uvm > c0)
-               ! E-faces (after stepu_C)
-               write(nu_diag,9000) 'AFTER stepu_C  F2E  min/max/avg =', &
-                  minval(F2E , mask=epm>c0),  maxval(F2E , mask=epm>c0),  &
-                  sum(F2E , mask=epm>c0)/real(max(1,nE),dbl_kind)
-               write(nu_diag,9000) 'AFTER stepu_C  KuE  min/max/avg =', &
-                  minval(KuE , mask=epm>c0),  maxval(KuE , mask=epm>c0),  &
-                  sum(KuE , mask=epm>c0)/real(max(1,nE),dbl_kind)
-               write(nu_diag,9000) 'AFTER stepu_C  KuxE min/max/avg =', &
-                  minval(KuxE, mask=epm>c0),  maxval(KuxE, mask=epm>c0),  &
-                  sum(KuxE, mask=epm>c0)/real(max(1,nE),dbl_kind)
-               write(nu_diag,9000) 'AFTER stepu_C  KuyE min/max/avg =', &
-                  minval(KuyE, mask=epm>c0),  maxval(KuyE, mask=epm>c0),  &
-                  sum(KuyE, mask=epm>c0)/real(max(1,nE),dbl_kind)
-               ! N-faces (after stepv_C)
-               write(nu_diag,9000) 'AFTER stepv_C  F2N  min/max/avg =', &
-                  minval(F2N , mask=npm>c0),  maxval(F2N , mask=npm>c0),  &
-                  sum(F2N , mask=npm>c0)/real(max(1,nN),dbl_kind)
-               write(nu_diag,9000) 'AFTER stepv_C  KuN  min/max/avg =', &
-                  minval(KuN , mask=npm>c0),  maxval(KuN , mask=npm>c0),  &
-                  sum(KuN , mask=npm>c0)/real(max(1,nN),dbl_kind)
-               write(nu_diag,9000) 'AFTER stepv_C  KuxN min/max/avg =', &
-                  minval(KuxN, mask=npm>c0),  maxval(KuxN, mask=npm>c0),  &
-                  sum(KuxN, mask=npm>c0)/real(max(1,nN),dbl_kind)
-               write(nu_diag,9000) 'AFTER stepv_C  KuyN min/max/avg =', &
-                  minval(KuyN, mask=npm>c0),  maxval(KuyN, mask=npm>c0),  &
-                  sum(KuyN, mask=npm>c0)/real(max(1,nN),dbl_kind)
-               ! U-corners (after stressC_U / U-averaging)
-               write(nu_diag,9000) 'AFTER stressC_U KuU  min/max/avg =', &
-                  minval(KuU , mask=uvm>c0),  maxval(KuU , mask=uvm>c0),  &
-                  sum(KuU , mask=uvm>c0)/real(max(1,nU),dbl_kind)
-               write(nu_diag,9000) 'AFTER stressC_U KuxU min/max/avg =', &
-                  minval(KuxU, mask=uvm>c0),  maxval(KuxU, mask=uvm>c0),  &
-                  sum(KuxU, mask=uvm>c0)/real(max(1,nU),dbl_kind)
-               write(nu_diag,9000) 'AFTER stressC_U KuyU min/max/avg =', &
-                  minval(KuyU, mask=uvm>c0),  maxval(KuyU, mask=uvm>c0),  &
-                  sum(KuyU, mask=uvm>c0)/real(max(1,nU),dbl_kind)
+               write(nu_diag,9000) 'after stepu/v_C calls F2E min/max/avg =', &
+                  minval(F2E, mask=F2E/=c0), maxval(F2E, mask=F2E/=c0), &
+                  sum(F2E, mask=F2E/=c0)/real(max(1,nE), dbl_kind)
+               write(nu_diag,9000) 'after stepu/v_C calls F2N min/max/avg =', &
+                  minval(F2N, mask=F2N/=c0), maxval(F2N, mask=F2N/=c0), &
+                  sum(F2N, mask=F2N/=c0)/real(max(1,nN), dbl_kind)
+               write(nu_diag,9000) 'after stepu/v_C calls KuE min/max/avg =', &
+                  minval(KuE, mask=KuE/=c0), maxval(KuE, mask=KuE/=c0), &
+                  sum(KuE, mask=KuE/=c0)/real(max(1,nE), dbl_kind)
+               write(nu_diag,9000) 'after stepu/v_C calls KuN min/max/avg =', &
+                  minval(KuN, mask=KuN/=c0), maxval(KuN, mask=KuN/=c0), &
+                  sum(KuN, mask=KuN/=c0)/real(max(1,nN), dbl_kind)
+               write(nu_diag,9000) 'after stepu/v_C calls KuxE min/max/avg =', &
+                  minval(KuxE, mask=KuxE/=c0), maxval(KuxE, mask=KuxE/=c0), &
+                  sum(KuxE, mask=KuxE/=c0)/real(max(1,nE), dbl_kind)
+               write(nu_diag,9000) 'after stepu/v_C calls KuyN min/max/avg =', &
+                  minval(KuyN, mask=KuyN/=c0), maxval(KuyN, mask=KuyN/=c0), &
+                  sum(KuyN, mask=KuyN/=c0)/real(max(1,nN), dbl_kind)
             end if
             ! ----------------------------------------------------------------------
 
-
             ! calls ice_haloUpdate, controls bundles and masks
             call dyn_haloUpdate (halo_info,       halo_info_mask,    &
                                  field_loc_Eface, field_type_vector, &
diff --git a/cicecore/cicedyn/dynamics/ice_dyn_shared.F90 b/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
index 8f379cd..9ec9e60 100644
--- a/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
+++ b/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
@@ -15,6 +15,7 @@ module ice_dyn_shared
       use ice_constants, only: omega, spval_dbl, p01, p001, p5
       use ice_blocks, only: nx_block, ny_block
       use ice_domain_size, only: max_blocks
+      use ice_grid, only: grid_ice
       use ice_fileunits, only: nu_diag
       use ice_exit, only: abort_ice
       use icepack_intfc, only: icepack_warnings_flush, icepack_warnings_aborted
@@ -64,9 +65,9 @@ module ice_dyn_shared
          boundary_condition       ! 'no_slip' (Dirchlet) or 'free_slip' (Neumann); boundary conditions
 
       real (kind=dbl_kind), parameter, public :: &
-         !u0    = 5e-5_dbl_kind, & ! residual velocity for seabed stress (m/s)
-         cosw  = c1           , & ! cos(ocean turning angle)  ! turning angle = 0
-         sinw  = c0               ! sin(ocean turning angle)  ! turning angle = 0
+         ! u0     = 5e-5_dbl_kind, & ! residual velocity for seabed stress (m/s)
+         cosw   = c1           , & ! cos(ocean turning angle)  ! turning angle = 0
+         sinw   = c0               ! sin(ocean turning angle)  ! turning angle = 0
 
       real (kind=dbl_kind), public :: &
          revp        , & ! 0 for classic EVP, 1 for revised EVP
@@ -148,11 +149,10 @@ module ice_dyn_shared
          create_form_factors ! if true, create the coastal form factors using the coastline
 
       ! real(kind=dbl_kind), dimension(:,:,:), allocatable, public :: &
-      !    F2_loc     ! coastal form factors
-      
-      real(kind=dbl_kind), dimension(:,:,:), allocatable, public :: &
-         F2E(:,:,:), F2N(:,:,:)
-      logical(kind=log_kind),       public, save :: cdp_ff_built = .false._log_kind
+      !    F2_loc     ! coastal form factors      
+      ! real(kind=dbl_kind), dimension(:,:,:), allocatable, public :: &
+      !    F2E(:,:,:), F2N(:,:,:)
+      ! logical(kind=log_kind),       public, save :: cdp_ff_built = .false._log_kind
 
       ! character (len=char_len), public :: &
       !    coastline_file       ! NetCDF of coastline
@@ -1576,38 +1576,95 @@ subroutine coastal_drag_stress_factor(nx_block, ny_block, &
                                             icellU  ,           &
                                             indxUi  , indxUj  , &
                                             imass   ,           &
-                                            Ku      ,           & 
-                                            F2_loc              ) 
-      character(len=*), parameter :: subname = '(coastal_drag_stress_factor)'
-      ! blocks:
-      integer (kind=int_kind), intent(in) :: &
-         nx_block, ny_block, & ! block dimensions
-         icellU                ! no. of cells where ice[uen]mask = 1
-      ! loop indeces
-      integer (kind=int_kind) :: i, j, ij
-      ! directional (grid) indeces:
-      integer (kind=int_kind), dimension (nx_block*ny_block), intent(in) :: &
-         indxUi, & ! compressed index in i-direction
-         indxUj    ! compressed index in j-direction
-      ! sea ice variables: 
-      real (kind=dbl_kind), dimension (nx_block,ny_block), intent(in) :: &
-         imass, & ! total mass of sea ice (includes snow) at E or N grid points
-         F2_loc       ! coastline form factor -- computed offline; (N/m^2)
-      ! compute Ku at each grid point 
-      ! (away from the coast it should go to zero as F2_loc goes to zero)
-      real (kind=dbl_kind), dimension (nx_block,ny_block), intent(inout) :: &
-         Ku       ! coastal drag stress factor (N/m^2)
-      ! (optional but handy: print once on master)
-      if (my_task == master_task) then
-          write(nu_diag, '(a,2f12.5)') 'ice_dyn_shared.F90 F2_loc(min,max)=', minval(F2_loc), maxval(F2_loc)
-      endif
-      do ij = 1, icellU
-         i       = indxUi(ij)
-         j       = indxUj(ij)
-         Ku(i,j) = imass(i,j) * F2_loc(i,j) * Cs
-      enddo ! ij
+                                            Ku      ,           &
+                                            F2_loc)
+         use ice_kinds_mod
+         use ice_fileunits  , only: nu_diag
+         use ice_communicate, only: my_task, master_task
+
+         implicit none
+
+         integer (kind=int_kind), intent(in)    :: nx_block, ny_block, icellU
+         integer (kind=int_kind)                :: i, j, ij, nset
+         integer (kind=int_kind), intent(in)    :: indxUi(nx_block*ny_block), indxUj(nx_block*ny_block)
+         real    (kind=dbl_kind), intent(in)    :: imass(nx_block,ny_block)
+         real    (kind=dbl_kind), intent(inout) :: Ku   (nx_block,ny_block)
+         real    (kind=dbl_kind), intent(in)    :: F2_loc(nx_block,ny_block)
+
+         ! define state
+         Ku   = c0
+         nset = 0
+
+         ! gauard 
+         if (icellU <= 0) then
+            if (my_task==master_task) write(nu_diag,'(a)') 'CDP: icellU==0; Ku unchanged.'
+            return
+         end if
+         if (my_task==master_task) then
+            write(nu_diag,'(a,1pe12.4)') 'CDP: Cs =', Cs
+            write(nu_diag,'(a,2(1pe12.4,1x))') 'CDP: F2_loc(mask) min/max =', &
+               minval(F2_loc, mask=F2_loc>c0), maxval(F2_loc, mask=F2_loc>c0)
+            write(nu_diag,'(a,2(1pe12.4,1x))') 'CDP: imass@F2>0 min/max =', &
+               minval(imass , mask=F2_loc>c0), maxval(imass , mask=F2_loc>c0)
+            write(nu_diag,'(a,i0)') 'CDP: icellU =', icellU
+         end if
+
+         do ij = 1, icellU
+            i = indxUi(ij);  j = indxUj(ij)
+            if (F2_loc(i,j) > c0) then
+               Ku(i,j) = imass(i,j) * F2_loc(i,j) * Cs
+               if (Ku(i,j) /= c0) nset = nset + 1
+            end if
+         end do
+
+         if (my_task==master_task) then
+            write(nu_diag,'(a,i0)') 'CDP: Ku nonzero count =', nset
+            if (nset > 0) then
+               write(nu_diag,'(a,2(1pe12.4,1x),a,1pe12.4)') 'CDP: Ku@F2>0 min/max/avg =', &
+               minval(Ku, mask=F2_loc>c0), maxval(Ku, mask=F2_loc>c0), ' ', &
+               sum(Ku, mask=F2_loc>c0)/real(nset,dbl_kind)
+            else
+               write(nu_diag,'(a)') 'CDP: Ku all zero on F2>0.'
+            end if
+         end if
       end subroutine coastal_drag_stress_factor
 
+      ! subroutine coastal_drag_stress_factor(nx_block, ny_block, &
+      !                                       icellU  ,           &
+      !                                       indxUi  , indxUj  , &
+      !                                       imass   ,           &
+      !                                       Ku      ,           & 
+      !                                       F2_loc              ) 
+      ! character(len=*), parameter :: subname = '(coastal_drag_stress_factor)'
+      ! ! blocks:
+      ! integer (kind=int_kind), intent(in) :: &
+      !    nx_block, ny_block, & ! block dimensions
+      !    icellU                ! no. of cells where ice[uen]mask = 1
+      ! ! loop indeces
+      ! integer (kind=int_kind) :: i, j, ij
+      ! ! directional (grid) indeces:
+      ! integer (kind=int_kind), dimension (nx_block*ny_block), intent(in) :: &
+      !    indxUi, & ! compressed index in i-direction
+      !    indxUj    ! compressed index in j-direction
+      ! ! sea ice variables: 
+      ! real (kind=dbl_kind), dimension (nx_block,ny_block), intent(in) :: &
+      !    imass, & ! total mass of sea ice (includes snow) at E or N grid points
+      !    F2_loc       ! coastline form factor -- computed offline; (N/m^2)
+      ! ! compute Ku at each grid point 
+      ! ! (away from the coast it should go to zero as F2_loc goes to zero)
+      ! real (kind=dbl_kind), dimension (nx_block,ny_block), intent(inout) :: &
+      !    Ku       ! coastal drag stress factor (N/m^2)
+      ! ! (optional but handy: print once on master)
+      ! if (my_task == master_task) then
+      !     write(nu_diag, '(a,2f12.5)') 'ice_dyn_shared.F90 F2_loc(min,max)=', minval(F2_loc), maxval(F2_loc)
+      ! endif
+      ! do ij = 1, icellU
+      !    i       = indxUi(ij)
+      !    j       = indxUj(ij)
+      !    Ku(i,j) = imass(i,j) * F2_loc(i,j) * Cs
+      ! enddo ! ij
+      ! end subroutine coastal_drag_stress_factor
+
 !=======================================================================
 ! Computes seabed (basal) stress factor TbU (landfast ice) based on mean
 ! thickness and bathymetry data. LKD refers to linear keel draft. This
@@ -2768,20 +2825,6 @@ subroutine strain_rates_U_free_slip(nx_block, ny_block,  &
             ! shear = 2 e_12
             shearU(i,j) =  dxU(i,j) * (uEijp1 - uEij) - uvelU(i,j) * (dxE(i  ,j+1) - dxE(i,j))  &
                         +  dyU(i,j) * (vNip1j - vNij) - vvelU(i,j) * (dyN(i+1,j  ) - dyN(i,j))
-         ! ! ---------- Diagnostics: print coastal U only (last subcycle) ----------
-         ! if (ksub == ndte) then
-         !    ! U(i,j) is the NE corner of T(i,j). It is "coastal" if any of the
-         !    ! four faces meeting at the corner are land (mask==0).
-         !    ! Adjacent faces around U(i,j): E(i,j), E(i,j-1), N(i,j), N(i-1,j)
-         !    if (i >= 2 .and. j >= 2 .and. i <= nx_block-1 .and. j <= ny_block-1) then
-         !       if ( (epm(i  ,j  ) == c0) .or. (epm(i  ,j-1) == c0) .or. &
-         !            (npm(i  ,j  ) == c0) .or. (npm(i-1,j  ) == c0) ) then
-         !          !$OMP CRITICAL (IO_DIAG)
-         !          write(nu_diag,'(a,2i6,1p,e16.8)') 'free-slip U-coast shearU  (i,j)=', i, j, shearU(i,j)
-         !          !$OMP END CRITICAL (IO_DIAG)
-         !       end if
-         !    end if
-         ! end if
       enddo
       if (ksub == ndte) call flush(nu_diag)
       end subroutine strain_rates_U_free_slip
diff --git a/cicecore/cicedyn/general/ice_init.F90 b/cicecore/cicedyn/general/ice_init.F90
index d48da4c..f1d795e 100644
--- a/cicecore/cicedyn/general/ice_init.F90
+++ b/cicecore/cicedyn/general/ice_init.F90
@@ -114,8 +114,8 @@ subroutine input_data
           grid_ocn, grid_ocn_thrm, grid_ocn_dynu, grid_ocn_dynv, &
           grid_atm, grid_atm_thrm, grid_atm_dynu, grid_atm_dynv, &
           dxrect, dyrect, dxscale, dyscale, scale_dxdy, &
-          lonrefrect, latrefrect, save_ghte_ghtn, &
-          F2E, F2N
+         lonrefrect, latrefrect, save_ghte_ghtn!, &
+         !  F2E, F2N
       use ice_dyn_shared, only: &
           ndte, kdyn, revised_evp, yield_curve, &
           evp_algorithm, visc_method,     &
diff --git a/cicecore/cicedyn/infrastructure/ice_grid.F90 b/cicecore/cicedyn/infrastructure/ice_grid.F90
index 18bb196..390c94a 100644
--- a/cicecore/cicedyn/infrastructure/ice_grid.F90
+++ b/cicecore/cicedyn/infrastructure/ice_grid.F90
@@ -244,6 +244,8 @@ subroutine alloc_grid
          umaskCD  (nx_block,ny_block,max_blocks), & ! land/boundary mask, velocity (U-cell)
          nmask    (nx_block,ny_block,max_blocks), & ! land/boundary mask (N-cell)
          emask    (nx_block,ny_block,max_blocks), & ! land/boundary mask (E-cell)
+         F2N      (nx_block,ny_block,max_blocks), & ! coastal drag form factors (N-cell)
+         F2E      (nx_block,ny_block,max_blocks), & ! coastal drag form factors (E-cell)
          opmask   (nx_block,ny_block,max_blocks), & ! land/boundary orphan mask (atm ocean/ice cell)
          lmask_n  (nx_block,ny_block,max_blocks), & ! northern hemisphere mask
          lmask_s  (nx_block,ny_block,max_blocks), & ! southern hemisphere mask
@@ -2608,7 +2610,6 @@ subroutine rectgrid_scale_dxdy
 
       end subroutine rectgrid_scale_dxdy
 
-
 !=======================================================================
 subroutine build_F2_form_factors_cgrid(coast_file, coast_var, F2_value, test_case)
    use ice_kinds_mod
@@ -2616,7 +2617,6 @@ subroutine build_F2_form_factors_cgrid(coast_file, coast_var, F2_value, test_cas
    use ice_domain     , only: nblocks, blocks_ice
    use ice_domain_size, only: max_blocks
    use ice_fileunits  , only: nu_diag
-   use ice_dyn_shared , only: F2E, F2N, cdp_ff_built 
 #ifdef _NETCDF
    use netcdf
 #endif
@@ -2627,10 +2627,6 @@ subroutine build_F2_form_factors_cgrid(coast_file, coast_var, F2_value, test_cas
    real   (kind=dbl_kind),   intent(in), optional :: F2_value    ! default 0.25
    logical(kind=log_kind),   intent(in), optional :: test_case   ! if true and no coast_file, treat perimeter as coastline
 
-   ! ! ---- REQUIRED outputs (already allocated by caller) ----
-   ! real(kind=dbl_kind), intent(out) :: F2E(nx_block,ny_block,max_blocks)
-   ! real(kind=dbl_kind), intent(out) :: F2N(nx_block,ny_block,max_blocks)
-
    ! ----- locals -----
    type(block)               :: this_block
    integer(kind=int_kind)    :: iblk, i, j, ilo, ihi, jlo, jhi
@@ -2654,10 +2650,8 @@ subroutine build_F2_form_factors_cgrid(coast_file, coast_var, F2_value, test_cas
    want_perimeter = .false.; if (present(test_case)) want_perimeter = test_case
 
    ! ----- allocate/clear outputs -----
-   if (.not. allocated(F2E)) allocate(F2E(nx_block,ny_block,max_blocks))
-   if (.not. allocated(F2N)) allocate(F2N(nx_block,ny_block,max_blocks))
-   F2E = 0.0d0
-   F2N = 0.0d0
+   F2E = c0
+   F2N = c0
 
    ! ----- choose coastline source -----
    use_coast = .false.
@@ -2769,8 +2763,6 @@ subroutine build_F2_form_factors_cgrid(coast_file, coast_var, F2_value, test_cas
       end if
    end if
 
-   cdp_ff_built = .true._log_kind
-
    ! ----- cleanup -----
    if (use_coast) then
       if (allocated(coastT)) deallocate(coastT)
-- 
2.43.7

