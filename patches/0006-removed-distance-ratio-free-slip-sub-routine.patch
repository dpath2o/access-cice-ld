From e1ec41d99b3abeb1b8b40ab101872908ef78924e Mon Sep 17 00:00:00 2001
From: dpath2o <dpath2o@mac.com>
Date: Wed, 22 Oct 2025 06:39:53 +1100
Subject: [PATCH 06/34] removed distance ratio free-slip sub-routine

---
 cicecore/cicedyn/analysis/ice_diagnostics.F90 |  60 +++++-
 cicecore/cicedyn/analysis/ice_history.F90     | 109 +++++++++--
 .../cicedyn/analysis/ice_history_shared.F90   |  23 ++-
 cicecore/cicedyn/dynamics/ice_dyn_evp.F90     |  31 ++--
 cicecore/cicedyn/dynamics/ice_dyn_shared.F90  | 171 +++---------------
 cicecore/cicedyn/general/ice_flux.F90         |  27 ++-
 6 files changed, 234 insertions(+), 187 deletions(-)

diff --git a/cicecore/cicedyn/analysis/ice_diagnostics.F90 b/cicecore/cicedyn/analysis/ice_diagnostics.F90
index 3a6ceb8..a4306f9 100644
--- a/cicecore/cicedyn/analysis/ice_diagnostics.F90
+++ b/cicecore/cicedyn/analysis/ice_diagnostics.F90
@@ -126,11 +126,17 @@ subroutine runtime_diags (dt)
           update_ocn_f, cpl_frazil, Tair, Qa, fsw, fcondtop, meltt, meltb, meltl, snoice, &
           dsnow, congel, sst, sss, Tf, fhocn, &
           swvdr, swvdf, swidr, swidf, &
-          alvdr_init, alvdf_init, alidr_init, alidf_init
+          alvdr_init, alvdf_init, alidr_init, alidf_init!, &
+          ! dpath2o
+          ! KuxE, KuyN
       use ice_flux_bgc, only: faero_atm, faero_ocn, fiso_atm, fiso_ocn
       use ice_global_reductions, only: global_sum, global_sum_prod, global_maxval
-      use ice_grid, only: lmask_n, lmask_s, tarean, tareas, grid_ice, grid_average_X2Y
+      use ice_grid, only: lmask_n, lmask_s, tarean, tareas, grid_ice, grid_average_X2Y!, &
+      ! dpath2o
+      !                     F2E, F2N
       use ice_state   ! everything
+      ! dpath2o
+      ! use ice_dyn_shared, only: coastal_drag!, coastal_form_factor_E, coastal_form_factor_N
 ! tcraig, this is likely to cause circular dependency because ice_prescribed_mod is high level routine
 #ifdef CESMCOUPLED
       use ice_prescribed_mod, only: prescribed_ice
@@ -216,6 +222,14 @@ subroutine runtime_diags (dt)
 
       character(len=*), parameter :: subname = '(runtime_diags)'
 
+      ! dpath2o: locals for CDP print
+      real(kind=dbl_kind), parameter :: tiny = 1.0d-12
+      integer :: nactE, nactN
+      real(kind=dbl_kind) :: f2e_min, f2e_max, f2n_min, f2n_max
+      real(kind=dbl_kind) :: kuxE_mean, kuxE_max, kuyN_mean, kuyN_max
+      real(kind=dbl_kind) :: clE_max,  clN_max
+
+
       call icepack_query_parameters(ktherm_out=ktherm, calc_Tsfc_out=calc_Tsfc)
       call icepack_query_tracer_flags(tr_brine_out=tr_brine, tr_aero_out=tr_aero, &
            tr_pond_topo_out=tr_pond_topo, tr_fsd_out=tr_fsd, tr_iso_out=tr_iso, &
@@ -1082,6 +1096,48 @@ subroutine runtime_diags (dt)
         write(nu_diag,900) 'max ice speed    (m/s) = ',umaxn,  umaxs
         write(nu_diag,900) 'max strength    (kN/m) = ',pmaxn,  pmaxs
 
+         !-----------------------------------------------------------------------
+         ! dpath2o: Coastal Drag Parametrization (CDP) quick diagnostics
+         !-----------------------------------------------------------------------
+         ! if (coastal_drag .and. (grid_ice == 'C' .or. grid_ice == 'CD')) then
+         !    ! Active CDP faces (F2>0)
+         !    nactE = count( F2E > 0.0_dbl_kind )!count( coastal_form_factor_E > 0.0_dbl_kind )
+         !    nactN = count( F2N > 0.0_dbl_kind )
+
+         !    ! Basic F2 stats (over all faces)
+         !    f2e_min = minval(F2E);  f2e_max = maxval(F2E)!minval(coastal_form_factor_E);  f2e_max = maxval(coastal_form_factor_E)
+         !    f2n_min = minval(F2N);  f2n_max = maxval(F2N)
+
+         !    ! Stress magnitudes on active faces
+         !    if (nactE > 0) then
+         !       kuxE_mean = sum( abs(KuxE), mask = (F2E > 0.0_dbl_kind) ) / real(nactE,kind(dbl_kind))
+         !       kuxE_max  = maxval( abs(KuxE), mask = (F2E > 0.0_dbl_kind) )
+         !       ! |Cl| ≈ |KuxE| / |uE|
+         !       clE_max   = maxval( abs(KuxE) / (abs(uvelE) + tiny), mask = (F2E > 0.0_dbl_kind) )
+         !    else
+         !       kuxE_mean = 0.0_dbl_kind; kuxE_max = 0.0_dbl_kind; clE_max = 0.0_dbl_kind
+         !    end if
+
+         !    if (nactN > 0) then
+         !       kuyN_mean = sum( abs(KuyN), mask = (F2N > 0.0_dbl_kind) ) &
+         !                   / real(nactN,kind(dbl_kind))
+         !       kuyN_max  = maxval( abs(KuyN), mask = (F2N > 0.0_dbl_kind) )
+         !       ! |Cl| ≈ |KuyN| / |vN|
+         !       clN_max   = maxval( abs(KuyN) / (abs(vvelN) + tiny), mask = (F2N > 0.0_dbl_kind) )
+         !    else
+         !       kuyN_mean = 0.0_dbl_kind; kuyN_max = 0.0_dbl_kind; clN_max = 0.0_dbl_kind
+         !    end if
+
+         !    if (my_task == master_task) then
+         !       write(nu_diag,'(a,i8,a,i8)') 'CDP faces active (E,N) = ', nactE, ', ', nactN
+         !       write(nu_diag,'(a,2f9.3,a,2f9.3)') 'CDP F2 range  (E,N) = [', f2e_min, f2e_max, ']  [', f2n_min, f2n_max, ']'
+         !       write(nu_diag,'(a,2es12.4,a,2es12.4)') 'CDP |KuxE|(mean,max)= ', kuxE_mean, kuxE_max,  &
+         !                                              '   |KuyN|(mean,max)= ', kuyN_mean, kuyN_max
+         !       write(nu_diag,'(a,2es12.4)')           'CDP |ClE|_max, |ClN|_max= ', clE_max, clN_max
+         !    end if
+         ! end if
+
+
         if (print_global) then  ! global diags for conservations checks
 
 ! tcraig, this is likely to cause circular dependency because ice_prescribed_mod is high level routine
diff --git a/cicecore/cicedyn/analysis/ice_history.F90 b/cicecore/cicedyn/analysis/ice_history.F90
index a6eabe2..3d0cd5e 100644
--- a/cicecore/cicedyn/analysis/ice_history.F90
+++ b/cicecore/cicedyn/analysis/ice_history.F90
@@ -454,6 +454,15 @@ subroutine init_hist (dt)
          f_taubyN = f_tauby
          f_taubxE = f_taubx
          f_taubyE = f_tauby
+         ! dpath2o
+        !  f_KuxN   = f_Kux
+        !  f_KuyN   = f_Kuy
+        !  f_KuxE   = f_Kux
+        !  f_KuyE   = f_Kuy
+         f_shearU = f_shearU
+        !  f_F2E    = f_uvel
+        !  f_F2N    = f_uvel
+
       endif
 
       call broadcast_scalar (f_tlon, master_task)
@@ -692,6 +701,14 @@ subroutine init_hist (dt)
       call broadcast_scalar (f_sistreave, master_task)
       call broadcast_scalar (f_sistremax, master_task)
       call broadcast_scalar (f_sirdgthick, master_task)
+      ! dpath2o
+    !   call broadcast_scalar (f_KuxN, master_task)
+    !   call broadcast_scalar (f_KuyN, master_task)
+    !   call broadcast_scalar (f_KuxE, master_task)
+    !   call broadcast_scalar (f_KuyE, master_task)
+    !   call broadcast_scalar (f_F2N, master_task)
+    !   call broadcast_scalar (f_F2E, master_task)
+      call broadcast_scalar (f_shearU, master_task)
 
       call broadcast_scalar (f_aicen, master_task)
       call broadcast_scalar (f_vicen, master_task)
@@ -1325,6 +1342,39 @@ subroutine init_hist (dt)
              "positive is y direction on E grid", c1, c0,                &
              ns1, f_taubyE)
 
+        !-----------------------------
+        ! dpath2o: coastal drag stress
+        ! call define_hist_field(n_KuxN,"KuxN","N/m^2",nstr2D, ncstr, &
+        !     "coastal (lateral) drag stress (x)", &
+        !     "positive is x direction on N grid", c1, c0, ns1, f_KuxN)
+
+        ! call define_hist_field(n_KuyN,"KuyN","N/m^2",nstr2D, ncstr, &
+        !     "coastal (lateral) drag stress (y)", &
+        !     "positive is y direction on N grid", c1, c0, ns1, f_KuyN)
+
+        ! call define_hist_field(n_KuxE,"KuxE","N/m^2",estr2D, ecstr, &
+        !     "coastal (lateral) drag stress (x)", &
+        !     "positive is x direction on E grid", c1, c0, ns1, f_KuxE)
+
+        ! call define_hist_field(n_KuyE,"KuyE","N/m^2",estr2D, ecstr, &
+        !     "coastal (lateral) drag stress (y)", &
+        !     "positive is y direction on E grid", c1, c0, ns1, f_KuyE)
+
+        ! call define_hist_field(n_F2N, "F2N", "-", nstr2D, ncstr, &
+        !     "coastal drag form factor (unitless)", &
+        !     "static; N-face on C-grid", c1, c0, ns1, f_F2N)
+
+        ! call define_hist_field(n_F2E, "F2E", "-", estr2D, ecstr, &
+        !     "coastal drag form factor (unitless)", &
+        !     "static; E-face on C-grid", c1, c0, ns1, f_F2E)
+
+         call define_hist_field(n_shearU,"shearU","%/day",tstr2D, tcstr, &
+             "strain rate (shear) at U-points",                         &
+             "shear is instantaneous, on U-grid", secday*c100, c0,      &
+             ns1, f_shearU)
+        ! dpath2o
+        !-----------------------------
+
          call define_hist_field(n_strength,"strength","N/m",tstr2D, tcstr, &
              "compressive ice strength",                                 &
              "none", c1, c0,                                             &
@@ -2156,13 +2206,14 @@ subroutine accum_hist (dt)
       use ice_blocks, only: block, get_block, nx_block, ny_block
       use ice_domain, only: blocks_ice, nblocks
       use ice_domain_size, only: nfsd
-      use ice_grid, only: tmask, lmask_n, lmask_s, dxU, dyU, grid_ice
+      use ice_grid, only: tmask, lmask_n, lmask_s, dxU, dyU, grid_ice, & !dpath2o: F2E, F2N
       use ice_calendar, only: new_year, write_history, &
                               write_ic, timesecs, histfreq, nstreams, mmonth, &
                               new_month
       use ice_dyn_eap, only: a11, a12, e11, e12, e22, s11, s12, s22, &
           yieldstress11, yieldstress12, yieldstress22
       use ice_dyn_shared, only: kdyn, principal_stress
+      use ice_dyn_evp, only: shearU
       use ice_flux, only: fsw, flw, fsnow, frain, sst, sss, uocn, vocn, &
           frzmlt_init, scale_factor, fswabs, fswthru, alvdr, alvdf, alidr, alidf, &
           albice, albsno, albpnd, coszen, flat, fsens, flwout, evap, evaps, evapi, &
@@ -2182,21 +2233,22 @@ subroutine accum_hist (dt)
           stressp_2, stressp_3, stressp_4, sig1, sig2, sigP, &
           mlt_onset, frz_onset, dagedtt, dagedtd, fswint_ai, keffn_top, &
           snowfrac, alvdr_ai, alvdf_ai, alidr_ai, alidf_ai, update_ocn_f, &
-          cpl_frazil
-      use ice_arrays_column, only: snowfracn, Cdn_atm
-      use ice_history_shared ! almost everything
-      use ice_history_write, only: ice_write_hist
-      use ice_history_bgc, only: accum_hist_bgc
-      use ice_history_mechred, only: accum_hist_mechred
-      use ice_history_pond, only: accum_hist_pond
-      use ice_history_snow, only: accum_hist_snow, &
-          f_rhos_cmp, f_rhos_cnt, n_rhos_cmp, n_rhos_cnt
-      use ice_history_drag, only: accum_hist_drag
-      use icepack_intfc, only: icepack_mushy_density_brine, icepack_mushy_liquid_fraction
-      use icepack_intfc, only: icepack_mushy_temperature_mush
-      use ice_history_fsd, only: accum_hist_fsd
-      use ice_state ! almost everything
-      use ice_timers, only: ice_timer_start, ice_timer_stop, timer_readwrite
+          cpl_frazil!, &
+          ! dpath2o
+          ! KuxN, KuyN, KuxE, KuyE
+      use ice_arrays_column, only   : snowfracn, Cdn_atm
+      use ice_history_shared        ! almost everything
+      use ice_history_write, only   : ice_write_hist
+      use ice_history_bgc, only     : accum_hist_bgc
+      use ice_history_mechred, only : accum_hist_mechred
+      use ice_history_pond, only    : accum_hist_pond
+      use ice_history_snow, only    : accum_hist_snow, f_rhos_cmp, f_rhos_cnt, n_rhos_cmp, n_rhos_cnt
+      use ice_history_drag, only    : accum_hist_drag
+      use icepack_intfc, only       : icepack_mushy_density_brine, icepack_mushy_liquid_fraction
+      use icepack_intfc, only       : icepack_mushy_temperature_mush
+      use ice_history_fsd, only     : accum_hist_fsd
+      use ice_state                 ! almost everything
+      use ice_timers, only          : ice_timer_start, ice_timer_stop, timer_readwrite
 
       real (kind=dbl_kind), intent(in) :: &
          dt      ! time step
@@ -2667,6 +2719,22 @@ subroutine accum_hist (dt)
              call accum_hist_field(n_taubxE, iblk, taubxE(:,:,iblk), a2D)
          if (f_taubyE(1:1) /= 'x') &
              call accum_hist_field(n_taubyE, iblk, taubyE(:,:,iblk), a2D)
+         !--------------------------------
+         ! dpath2o: coastal drag stress (faces)
+        !  if (f_KuxN(1:1) /= 'x') &
+        !      call accum_hist_field(n_KuxN, iblk, KuxN(:,:,iblk), a2D)
+        !  if (f_KuyN(1:1) /= 'x') &
+        !      call accum_hist_field(n_KuyN, iblk, KuyN(:,:,iblk), a2D)
+        !  if (f_KuxE(1:1) /= 'x') &
+        !      call accum_hist_field(n_KuxE, iblk, KuxE(:,:,iblk), a2D)
+        !  if (f_KuyE(1:1) /= 'x') &
+        !      call accum_hist_field(n_KuyE, iblk, KuyE(:,:,iblk), a2D)
+        !  if (f_F2N(1:1) /= 'x') &
+        !      call accum_hist_field(n_F2N, iblk, F2N(:,:,iblk), a2D)
+        !  if (f_F2E(1:1) /= 'x') &
+        !      call accum_hist_field(n_F2E, iblk, F2E(:,:,iblk), a2D)
+        ! dpath2o
+        !------------------------------
          if (f_strength(1:1)/= 'x') &
              call accum_hist_field(n_strength,iblk, strength(:,:,iblk), a2D)
 
@@ -2687,6 +2755,10 @@ subroutine accum_hist (dt)
 !        if (f_trsig  (1:1) /= 'x') &
 !             call accum_hist_field(n_trsig,   iblk, trsig(:,:,iblk), a2D)
 
+        ! dpath2o
+        if (f_shearU (1:1) /= 'x') &
+            call accum_hist_field(n_shearU,   iblk, shearU(:,:,iblk), a2D)
+
          if (f_dvidtt (1:1) /= 'x') &
              call accum_hist_field(n_dvidtt,  iblk, dvidtt(:,:,iblk), a2D)
          if (f_dvidtd (1:1) /= 'x') &
@@ -4030,6 +4102,8 @@ subroutine accum_hist (dt)
               if (.not. tmask(i,j,iblk)) then ! mask out land points
                  if (n_divu     (ns) /= 0) a2D(i,j,n_divu(ns),     iblk) = spval_dbl
                  if (n_shear    (ns) /= 0) a2D(i,j,n_shear(ns),    iblk) = spval_dbl
+                 ! dpath2o
+                 if (n_shearU    (ns) /= 0) a2D(i,j,n_shearU(ns),    iblk) = spval_dbl
                  if (n_vort     (ns) /= 0) a2D(i,j,n_vort(ns),     iblk) = spval_dbl
                  if (n_sig1     (ns) /= 0) a2D(i,j,n_sig1(ns),     iblk) = spval_dbl
                  if (n_sig2     (ns) /= 0) a2D(i,j,n_sig2(ns),     iblk) = spval_dbl
@@ -4060,6 +4134,9 @@ subroutine accum_hist (dt)
                        divu (i,j,iblk)*avail_hist_fields(n_divu(ns))%cona
                  if (n_shear    (ns) /= 0) a2D(i,j,n_shear(ns),iblk)     = &
                        shear(i,j,iblk)*avail_hist_fields(n_shear(ns))%cona
+                 ! dpath2o
+                 if (n_shearU   (ns) /= 0) a2D(i,j,n_shearU(ns),iblk)     = &
+                       shear(i,j,iblk)*avail_hist_fields(n_shearU(ns))%cona
                  if (n_vort     (ns) /= 0) a2D(i,j,n_vort(ns),iblk)      = &
                        vort(i,j,iblk)*avail_hist_fields(n_vort(ns))%cona
                  if (n_sig1     (ns) /= 0) a2D(i,j,n_sig1(ns),iblk)      = &
diff --git a/cicecore/cicedyn/analysis/ice_history_shared.F90 b/cicecore/cicedyn/analysis/ice_history_shared.F90
index daa8057..2083c26 100644
--- a/cicecore/cicedyn/analysis/ice_history_shared.F90
+++ b/cicecore/cicedyn/analysis/ice_history_shared.F90
@@ -362,7 +362,13 @@ module ice_history_shared
            f_s22       = 'x', &
            f_yieldstress11  = 'x', &
            f_yieldstress12  = 'x', &
-           f_yieldstress22  = 'x'
+           f_yieldstress22  = 'x', &
+           ! dpath2o
+         !   f_Kux  = 'x', f_Kuy  = 'x', &
+         !   f_KuxN = 'x', f_KuyN = 'x', &
+         !   f_KuxE = 'x', f_KuyE = 'x', &
+         !   f_F2N  = 'x', f_F2E  = 'x', &
+           f_shearU = 'x'
 
       !---------------------------------------------------------------
       ! namelist variables
@@ -534,7 +540,12 @@ module ice_history_shared
            f_s22,       &
            f_yieldstress11, &
            f_yieldstress12, &
-           f_yieldstress22
+           f_yieldstress22, &
+           ! dpath2o
+         !   f_Kux , f_Kuy, f_F2N, f_F2E , &
+         !   f_KuxN, f_KuyN, &
+         !   f_KuxE, f_KuyE, &
+           f_shearU
 
       !---------------------------------------------------------------
       ! field indices
@@ -735,7 +746,13 @@ module ice_history_shared
            n_s11         , n_s12       , &
            n_s22         , &
            n_yieldstress11, n_yieldstress12, &
-           n_yieldstress22
+           n_yieldstress22, &
+           ! dpath2o
+         !   n_Kux , n_Kuy , &
+         !   n_KuxN, n_KuyN, &
+         !   n_KuxE, n_KuyE, &
+         !   n_F2N , n_F2E , &
+           n_shearU
 
       interface accum_hist_field ! generic interface
            module procedure accum_hist_field_2D, &
diff --git a/cicecore/cicedyn/dynamics/ice_dyn_evp.F90 b/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
index 3f1748f..a85cd57 100644
--- a/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
+++ b/cicecore/cicedyn/dynamics/ice_dyn_evp.F90
@@ -291,7 +291,7 @@ subroutine evp (dt)
           DminTarea, visc_method, deformations, deformationsC_T, deformationsCD_T, &
           strain_rates_U, dxhy, dyhx, cxp, cyp, cxm, cym, &
           iceTmask, iceUmask, iceEmask, iceNmask, &
-          dyn_haloUpdate, fld2, fld3, fld4, strain_rates_U_free_slip, strain_rates_U_free_slip_noratio
+          dyn_haloUpdate, fld2, fld3, fld4, strain_rates_U_free_slip
       use ice_dyn_evp1d, only: dyn_evp1d_run
 
       real (kind=dbl_kind), intent(in) :: &
@@ -954,7 +954,21 @@ subroutine evp (dt)
                !                      divergU (:,:,iblk), tensionU (:,:,iblk), &
                !                      shearU  (:,:,iblk), deltaU   (:,:,iblk), &
                !                      ksub              , ndte                 )
-               call strain_rates_U_free_slip_noratio (nx_block          , ny_block           , &
+               ! call strain_rates_U_free_slip_noratio (nx_block          , ny_block           , &
+               !                      icellU      (iblk),                      &
+               !                      indxUi    (:,iblk), indxUj     (:,iblk), &
+               !                      uvelE   (:,:,iblk), vvelE    (:,:,iblk), &
+               !                      uvelN   (:,:,iblk), vvelN    (:,:,iblk), &
+               !                      uvel    (:,:,iblk), vvel     (:,:,iblk), &
+               !                      dxE     (:,:,iblk), dyN      (:,:,iblk), &
+               !                      dxU     (:,:,iblk), dyU      (:,:,iblk), &
+               !                      ratiodxN(:,:,iblk), ratiodxNr(:,:,iblk), &
+               !                      ratiodyE(:,:,iblk), ratiodyEr(:,:,iblk), &
+               !                      epm     (:,:,iblk), npm      (:,:,iblk), &
+               !                      divergU (:,:,iblk), tensionU (:,:,iblk), &
+               !                      shearU  (:,:,iblk), deltaU   (:,:,iblk), &
+               !                      ksub              , ndte                 )
+               call strain_rates_U (nx_block          , ny_block           , &
                                     icellU      (iblk),                      &
                                     indxUi    (:,iblk), indxUj     (:,iblk), &
                                     uvelE   (:,:,iblk), vvelE    (:,:,iblk), &
@@ -968,19 +982,6 @@ subroutine evp (dt)
                                     divergU (:,:,iblk), tensionU (:,:,iblk), &
                                     shearU  (:,:,iblk), deltaU   (:,:,iblk), &
                                     ksub              , ndte                 )
-               ! call strain_rates_U (nx_block          , ny_block           , &
-               !                      icellU      (iblk),                      &
-               !                      indxUi    (:,iblk), indxUj     (:,iblk), &
-               !                      uvelE   (:,:,iblk), vvelE    (:,:,iblk), &
-               !                      uvelN   (:,:,iblk), vvelN    (:,:,iblk), &
-               !                      uvel    (:,:,iblk), vvel     (:,:,iblk), &
-               !                      dxE     (:,:,iblk), dyN      (:,:,iblk), &
-               !                      dxU     (:,:,iblk), dyU      (:,:,iblk), &
-               !                      ratiodxN(:,:,iblk), ratiodxNr(:,:,iblk), &
-               !                      ratiodyE(:,:,iblk), ratiodyEr(:,:,iblk), &
-               !                      epm     (:,:,iblk), npm      (:,:,iblk), &
-               !                      divergU (:,:,iblk), tensionU (:,:,iblk), &
-               !                      shearU  (:,:,iblk), deltaU   (:,:,iblk)  )
 
             enddo  ! iblk
             !$OMP END PARALLEL DO
diff --git a/cicecore/cicedyn/dynamics/ice_dyn_shared.F90 b/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
index 02c3271..580cdfd 100644
--- a/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
+++ b/cicecore/cicedyn/dynamics/ice_dyn_shared.F90
@@ -28,7 +28,6 @@ module ice_dyn_shared
                 seabed_stress_factor_LKD, seabed_stress_factor_prob, &
                 deformations, deformationsC_T, deformationsCD_T, &
                 strain_rates, strain_rates_T, strain_rates_U, strain_rates_U_free_slip, &
-                strain_rates_U_free_slip_noratio, &
                 visc_replpress, &
                 dyn_haloUpdate, &
                 stack_fields, unstack_fields
@@ -2290,12 +2289,15 @@ subroutine strain_rates_U (nx_block,   ny_block,  &
                                  ratiodyE,   ratiodyEr, &
                                  epm,        npm,       &
                                  divergU,    tensionU,  &
-                                 shearU,     DeltaU     )
+                                 shearU,     DeltaU,    &
+                                 ksub,       ndte       )
 
       integer (kind=int_kind), intent(in) :: &
          nx_block, ny_block, & ! block dimensions
          icellU
 
+      integer (kind=int_kind), intent(in) :: ksub, ndte
+
       integer (kind=int_kind), dimension (nx_block*ny_block), intent(in) :: &
          indxUi   , & ! compressed index in i-direction
          indxUj       ! compressed index in j-direction
@@ -2389,137 +2391,23 @@ subroutine strain_rates_U (nx_block,   ny_block,  &
 
       enddo
 
-      end subroutine strain_rates_U
-
-!=======================================================================
-! Compute strain rates at the U point — FREE-SLIP (Neumann)
-! Free-slip = zero normal flow; zero normal derivative of tangential
-!
-! IMPORTANT:
-!  - no clamping ratios: use rp = -ratio (mimic reflection)
-!  - No changes to calling signature versus no-slip version
-!  - Prints shearU at coastal U points (last subcycle only)
-!=======================================================================
-   subroutine strain_rates_U_free_slip(nx_block, ny_block,  &
-                                       icellU,              &
-                                       indxUi,   indxUj,    &
-                                       uvelE,    vvelE,     &
-                                       uvelN,    vvelN,     &
-                                       uvelU,    vvelU,     &
-                                       dxE,      dyN,       &
-                                       dxU,      dyU,       &
-                                       ratiodxN, ratiodxNr, &
-                                       ratiodyE, ratiodyEr, &
-                                       epm,      npm,       &
-                                       divergU,  tensionU,  &
-                                       shearU,   DeltaU,    &
-                                       ksub,     ndte)
-
-      use ice_kinds_mod, only: int_kind, dbl_kind
-      implicit none
-
-      !----------------------------
-      ! Arguments (identical to no-slip)
-      !----------------------------
-      integer (kind=int_kind), intent(in) :: nx_block, ny_block, icellU
-      integer (kind=int_kind), intent(in) :: ksub, ndte
-      integer (kind=int_kind), dimension (nx_block*ny_block), intent(in) :: &
-         indxUi, indxUj
-
-      real (kind=dbl_kind), dimension (nx_block,ny_block), intent(in) :: &
-         uvelE, vvelE, uvelN, vvelN, uvelU, vvelU, &
-         dxE, dyN, dxU, dyU, &
-         ratiodxN, ratiodxNr, ratiodyE, ratiodyEr, &
-         epm, npm
-
-      real (kind=dbl_kind), dimension (nx_block,ny_block), intent(out) :: &
-         divergU, tensionU, shearU, DeltaU
-
-      !----------------------------
-      ! Locals
-      !----------------------------
-      integer (kind=int_kind) :: ij, i, j
-      real (kind=dbl_kind) :: uNip1j, uNij, vEijp1, vEij, uEijp1, uEij, vNip1j, vNij
-      real (kind=dbl_kind) :: rpdxN, rpdxNr, rpdyE, rpdyEr
-
-      ! module constants assumed available in host: c0, e_factor, nu_diag
-      ! if not, add USE for their modules.
-
-      divergU (:,:) = c0
-      tensionU(:,:) = c0
-      shearU  (:,:) = c0
-      DeltaU  (:,:) = c0
-
-      !----------------------------
-      ! Build strains at U (free-slip)
-      !----------------------------
-      do ij = 1, icellU
-         i = indxUi(ij)
-         j = indxUj(ij)
-
-         ! Even reflection for free-slip: rp = - ratio (NO clamping to >= 0)
-         rpdxN  = -ratiodxN (i,j)
-         rpdxNr = -ratiodxNr(i,j)
-         rpdyE  = -ratiodyE (i,j)
-         rpdyEr = -ratiodyEr(i,j)
-
-         ! ---- e11 + e22 terms (divergence / tension use these du/dx, dv/dy parts) ----
-         ! u on N faces across x-direction (handles coast via mask+ratio)
-         uNip1j = uvelN(i+1,j) * npm(i+1,j) + (npm(i,j)   - npm(i+1,j)) * npm(i,j)   * rpdxN  * uvelN(i  ,j)
-         uNij   = uvelN(i  ,j) * npm(i  ,j) + (npm(i+1,j) - npm(i  ,j)) * npm(i+1,j) * rpdxNr * uvelN(i+1,j)
-
-         ! v on E faces across y-direction
-         vEijp1 = vvelE(i,j+1) * epm(i,  j+1) + (epm(i,  j) - epm(i,  j+1)) * epm(i,  j) * rpdyE  * vvelE(i,  j)
-         vEij   = vvelE(i,  j) * epm(i,  j  ) + (epm(i,  j+1) - epm(i,  j )) * epm(i,  j+1) * rpdyEr * vvelE(i,  j+1)
-
-         ! divergence  = e11 + e22  (area-weighted form)
-         divergU(i,j) = dyU(i,j)   * (uNip1j - uNij)     &
-                     + uvelU(i,j) * (dyN(i+1,j) - dyN(i,j)) &
-                     + dxU(i,j)   * (vEijp1 - vEij)     &
-                     + vvelU(i,j) * (dxE(i,j+1) - dxE(i,j))
-
-         ! tension     = e11 - e22
-         tensionU(i,j) = dyU(i,j)   * (uNip1j - uNij)     &
-                     - uvelU(i,j) * (dyN(i+1,j) - dyN(i,j)) &
-                     - dxU(i,j)   * (vEijp1 - vEij)     &
-                     + vvelU(i,j) * (dxE(i,j+1) - dxE(i,j))
-
-         ! ---- 2*e12 terms (shear uses du/dy on E and dv/dx on N with same BC logic) ----
-         uEijp1 = uvelE(i,  j+1) * epm(i,  j+1) + (epm(i,  j) - epm(i,  j+1)) * epm(i,  j) * rpdyE  * uvelE(i,  j)
-         uEij   = uvelE(i,  j  ) * epm(i,  j  ) + (epm(i,  j+1) - epm(i,  j )) * epm(i,  j+1) * rpdyEr * uvelE(i,  j+1)
-
-         vNip1j = vvelN(i+1,j  ) * npm(i+1,j  ) + (npm(i,  j) - npm(i+1,j)) * npm(i,  j) * rpdxN  * vvelN(i,  j)
-         vNij   = vvelN(i,  j  ) * npm(i,  j  ) + (npm(i+1,j) - npm(i,  j )) * npm(i+1,j) * rpdxNr * vvelN(i+1,j)
-
-         shearU(i,j) =  dxU(i,j) * (uEijp1 - uEij)               &
-                     - uvelU(i,j) * (dxE(i,  j+1) - dxE(i,  j))  &
-                     + dyU(i,j) * (vNip1j - vNij)                &
-                     - vvelU(i,j) * (dyN(i+1,j  ) - dyN(i,  j))
-
-         ! denominator helper
-         DeltaU(i,j) = sqrt( divergU(i,j)**2 + e_factor * ( tensionU(i,j)**2 + shearU(i,j)**2 ) )
-
-      end do
-
-      !----------------------------
-      ! Debug print: shearU at coastal U points (last subcycle only)
-      ! A U point is “coastal” if any of its 4 surrounding faces is masked
-      ! (uses epm/npm only; no tmask required)
-      !----------------------------
+      ! ---------- Diagnostics: print coastal U only (last subcycle) ----------
       if (ksub == ndte) then
          do j = 2, ny_block-1
             do i = 2, nx_block-1
-               if (epm(i,  j  ) == c0 .or. epm(i,  j-1) == c0 .or. &
-                  npm(i,  j  ) == c0 .or. npm(i-1,  j) == c0) then
-                  write(nu_diag,'(a,2i6,1x,es16.8)') 'free-slip shearU at coastal U (i,j,val)=', &
-                        i, j, shearU(i,j)
+               ! U(i,j) is “coastal” if any of its four surrounding faces is land
+               if ( epm(i  ,j  ) == c0 .or. epm(i  ,j-1) == c0 .or. &
+                    npm(i  ,j  ) == c0 .or. npm(i-1,j  ) == c0 ) then
+                  !$OMP CRITICAL (IO_DIAG)
+                  write(nu_diag,'(a,2i6,1p,e16.8)') 'no-slip U-coast shearU  (i,j)=', i, j, shearU(i,j)
+                  !$OMP END CRITICAL (IO_DIAG)
                end if
             end do
          end do
          call flush(nu_diag)
       end if
 
-   end subroutine strain_rates_U_free_slip
+      end subroutine strain_rates_U
 
 !=======================================================================
 ! Compute strain rates at the U point — FREE-SLIP (Neumann)
@@ -2536,7 +2424,7 @@ end subroutine strain_rates_U_free_slip
 !    component vanishes at the wall.
 !  - Signature kept identical to the no-slip routine.
 !=======================================================================
-      subroutine strain_rates_U_free_slip_noratio(nx_block, ny_block,  &
+      subroutine strain_rates_U_free_slip(nx_block, ny_block,  &
                                           icellU,              &
                                           indxUi,   indxUj,    &
                                           uvelE,    vvelE,     &
@@ -2582,38 +2470,25 @@ subroutine strain_rates_U_free_slip_noratio(nx_block, ny_block,  &
             i = indxUi(ij)
             j = indxUj(ij)
 
-            ! --- “dv/dx” part on E-grid uses (i,j+1) and (i,j) samples
-            ! If epm(i,j+1)==0 and epm(i,j)==1 -> substitute vE(i,j+1) := +vE(i,j)
+            ! dv/dx
             vEijp1 = vvelE(i,j+1)*epm(i,j+1) + (epm(i,j)   - epm(i,j+1)) * epm(i,j)   * vvelE(i,j)
-            vEij   = vvelE(i,j  )*epm(i,j  ) + (epm(i,j+1) - epm(i,j  ) ) * epm(i,j+1) * vvelE(i,j+1)
+            vEij   = vvelE(i,j  )*epm(i,j  ) + (epm(i,j+1) - epm(i,j  )) * epm(i,j+1) * vvelE(i,j+1)
 
-            ! --- “du/dx or du/dy” part on N-grid using (i+1,j) and (i,j)
-            ! If npm(i+1,j)==0 and npm(i,j)==1 -> substitute uN(i+1,j) := +uN(i,j)
+            ! du/dy
             uNip1j = uvelN(i+1,j)*npm(i+1,j) + (npm(i,j)   - npm(i+1,j)) * npm(i,j)   * uvelN(i  ,j)
-            uNij   = uvelN(i  ,j)*npm(i  ,j) + (npm(i+1,j) - npm(i  ,j) ) * npm(i+1,j) * uvelN(i+1,j)
-
-            ! divergence  =  e_11 + e_22
-            divergU(i,j) = dyU(i,j)   * (uNip1j - uNij)   + uvelU(i,j) * (dyN(i+1,j) - dyN(i,j)) &
-                        +  dxU(i,j)   * (vEijp1 - vEij)   + vvelU(i,j) * (dxE(i  ,j+1) - dxE(i,j))
+            uNij   = uvelN(i  ,j)*npm(i  ,j) + (npm(i+1,j) - npm(i  ,j)) * npm(i+1,j) * uvelN(i+1,j)
 
-            ! tension = e_11 - e_22
-            tensionU(i,j)= dyU(i,j)   * (uNip1j - uNij)   - uvelU(i,j) * (dyN(i+1,j) - dyN(i,j)) &
-                        -  dxU(i,j)   * (vEijp1 - vEij)   + vvelU(i,j) * (dxE(i  ,j+1) - dxE(i,j))
-
-            ! --- “du/dy or du/dx” on E-grid for u
+            ! du/dx
             uEijp1 = uvelE(i,j+1)*epm(i,j+1) + (epm(i,j)   - epm(i,j+1)) * epm(i,j)   * uvelE(i  ,j)
-            uEij   = uvelE(i,j  )*epm(i,j  ) + (epm(i,j+1) - epm(i,j  ) ) * epm(i,j+1) * uvelE(i  ,j+1)
+            uEij   = uvelE(i,j  )*epm(i,j  ) + (epm(i,j+1) - epm(i,j  )) * epm(i,j+1) * uvelE(i  ,j+1)
 
-            ! --- “dv/dy” on N-grid for v
+            ! dv/dy
             vNip1j = vvelN(i+1,j)*npm(i+1,j) + (npm(i,j)   - npm(i+1,j)) * npm(i,j)   * vvelN(i  ,j)
-            vNij   = vvelN(i  ,j)*npm(i  ,j) + (npm(i+1,j) - npm(i  ,j) ) * npm(i+1,j) * vvelN(i+1,j)
+            vNij   = vvelN(i  ,j)*npm(i  ,j) + (npm(i+1,j) - npm(i  ,j)) * npm(i+1,j) * vvelN(i+1,j)
 
             ! shear = 2 e_12
             shearU(i,j) =  dxU(i,j) * (uEijp1 - uEij) - uvelU(i,j) * (dxE(i  ,j+1) - dxE(i,j))  &
-                        + dyU(i,j) * (vNip1j - vNij) - vvelU(i,j) * (dyN(i+1,j) - dyN(i,j))
-
-            ! Delta for viscosities
-            DeltaU(i,j) = sqrt( divergU(i,j)**2 + e_factor * ( tensionU(i,j)**2 + shearU(i,j)**2 ) )
+                        +  dyU(i,j) * (vNip1j - vNij) - vvelU(i,j) * (dyN(i+1,j  ) - dyN(i,j))
          end do
 
          ! ---------- Diagnostics: print coastal U only (last subcycle) ----------
@@ -2632,7 +2507,7 @@ subroutine strain_rates_U_free_slip_noratio(nx_block, ny_block,  &
             call flush(nu_diag)
          end if
 
-      end subroutine strain_rates_U_free_slip_noratio
+      end subroutine strain_rates_U_free_slip
 
 !=======================================================================
 ! Computes viscosities and replacement pressure for stress
diff --git a/cicecore/cicedyn/general/ice_flux.F90 b/cicecore/cicedyn/general/ice_flux.F90
index ff71a4a..ea8bf77 100644
--- a/cicecore/cicedyn/general/ice_flux.F90
+++ b/cicecore/cicedyn/general/ice_flux.F90
@@ -112,7 +112,10 @@ module ice_flux
          dardg1dt, & ! rate of area loss by ridging ice (1/s)
          dardg2dt, & ! rate of area gain by new ridges (1/s)
          dvirdgdt, & ! rate of ice volume ridged (m/s)
-         opening     ! rate of opening due to divergence/shear (1/s)
+         opening , & ! rate of opening due to divergence/shear (1/s)
+         ! dpath2o
+         ! KuxN, KuyN, KuxE, KuyE, & ! coastal drag stress components on C-grid (N/m^2)
+         shearU
 
       real (kind=dbl_kind), dimension (:,:,:,:), allocatable, public :: &
        ! ridging diagnostics in categories
@@ -147,7 +150,9 @@ module ice_flux
          fmE      , & ! Coriolis param. * mass in E-cell (kg/s)
          TbE      , & ! factor for seabed stress (N/m^2)
          fmN      , & ! Coriolis param. * mass in N-cell (kg/s)
-         TbN          ! factor for seabed stress (N/m^2)
+         TbN      !, & ! factor for seabed stress (N/m^2)
+         ! dpath2o
+         ! KuN, KuE     ! coastal drag stress on C-grid component locations (N/m^2)
 
       !-----------------------------------------------------------------
       ! Thermodynamic component
@@ -657,6 +662,14 @@ subroutine alloc_flux
          stresspU   (nx_block,ny_block,max_blocks), & ! sigma11+sigma22
          stressmU   (nx_block,ny_block,max_blocks), & ! sigma11-sigma22
          stress12U  (nx_block,ny_block,max_blocks), & ! sigma12
+         ! dpath2o
+         ! KuN        (nx_block,ny_block,max_blocks), & ! coastal drag stress factor at N points (landfast ice)
+         ! KuxN       (nx_block,ny_block,max_blocks), & ! coastal drag stress (x) at N points (N/m^2)
+         ! KuyN       (nx_block,ny_block,max_blocks), & ! coastal drag stress (y) at N points (N/m^2)
+         ! KuE        (nx_block,ny_block,max_blocks), & ! coastal drag stress factor at E points (landfast ice)
+         ! KuxE       (nx_block,ny_block,max_blocks), & ! coastal drag stress (x) at E points (N/m^2)
+         ! KuyE       (nx_block,ny_block,max_blocks), & ! coastal drag stress (y) at E points (N/m^2)
+         shearU     (nx_block,ny_block,max_blocks), & !
          stat=ierr)
       if (ierr/=0) call abort_ice('(alloc_flux): Out of memory (C or CD grid)')
 
@@ -1138,7 +1151,7 @@ subroutine init_history_dyn
       vort    (:,:,:) = c0
       taubxU  (:,:,:) = c0
       taubyU  (:,:,:) = c0
-      strength (:,:,:) = c0
+      strength(:,:,:) = c0
       strocnxU(:,:,:) = c0
       strocnyU(:,:,:) = c0
       strairxU(:,:,:) = c0
@@ -1196,6 +1209,14 @@ subroutine init_history_dyn
          strintyN   (:,:,:) = c0
          fmN        (:,:,:) = c0
          TbN        (:,:,:) = c0
+         ! dpath2o
+         ! KuN        (:,:,:) = c0
+         ! KuE        (:,:,:) = c0
+         ! KuxN       (:,:,:) = c0
+         ! KuyN       (:,:,:) = c0
+         ! KuxE       (:,:,:) = c0
+         ! KuyE       (:,:,:) = c0
+         shearU     (:,:,:) = c0
       end if
       end subroutine init_history_dyn
 
-- 
2.43.7

