From 6396109766bae1b66fb04dcd66f8a2ad62cd2a85 Mon Sep 17 00:00:00 2001
From: dpath2o <dpath2o@mac.com>
Date: Wed, 21 Jan 2026 23:06:37 +1100
Subject: [PATCH 29/34] minor updates

---
 cicecore/cicedyn/general/ice_forcing.F90 | 617 ++++++-----------------
 1 file changed, 158 insertions(+), 459 deletions(-)

diff --git a/cicecore/cicedyn/general/ice_forcing.F90 b/cicecore/cicedyn/general/ice_forcing.F90
index 380d66d..01bcbfb 100755
--- a/cicecore/cicedyn/general/ice_forcing.F90
+++ b/cicecore/cicedyn/general/ice_forcing.F90
@@ -1999,386 +1999,71 @@ end subroutine ERA5_data
    !
    ! author: dpath2o Jan.26
    !-----------------------------------------------------------------------
-   ! subroutine AFIM_data(dt)
-   !    use ice_blocks, only            : nx_block, ny_block
-   !    use ice_read_write, only        : ice_read_nc, ice_open_nc, ice_close_nc
-   !    use ice_global_reductions, only : global_minval, global_maxval
-   !    use ice_domain, only            : distrb_info, nblocks
-   !    use ice_flux, only              : sss, sst, uocn, vocn, Tf ! CICE INTERNAL OCEAN 
-   !    use ice_grid, only              : hm, tmask, umask
-   !    use ice_calendar, only          : days_per_year, months_per_year, mmonth, myear, yday, mday, msec
-   !    use ice_restart_shared, only    : restart
-   !    use ice_state, only             : aice     ! needed for w(aice)
-   !    use, intrinsic :: ieee_arithmetic, only : ieee_is_finite
-   !    implicit none
-   !    real(kind=dbl_kind) :: Tf_loc, sst_sc_floor
-   !    real(kind=dbl_kind), parameter :: dT_sc_max = 0.20_dbl_kind   ! allow 0.2 C supercooling (tunable)
-   !    ! variable assignments
-   !    real(kind=dbl_kind), intent(in) :: dt
-   !    integer(kind=int_kind)          :: fid, i, j, iblk, rec0, rec1, maxrec, dataloc, fyr, modadj
-   !    real(kind=dbl_kind)             :: secday, sst_tgt, sss_tgt, u_tgt, v_tgt, vmin, vmax
-   !    logical                         :: need_read_slot1, need_read_slot2, first_half
-   !    character(len=*), parameter     :: subname = '(AFIM_data)'
-   !    ! --- cached state (persists across calls) ---
-   !    integer(kind=int_kind), save    :: last_fyr = -999999
-   !    integer(kind=int_kind), save    :: last_rec_slot(2) = (/ -999999, -999999 /)  ! slot1, slot2
-   !    ! --- local vars for weighted restoring ---
-   !    real(kind=dbl_kind)             :: a, w, wraw, sst_tgt_eff, tauT, tauS, facT, facS, TT_loc, TS_loc, a0_loc, pw_loc
-   !    integer(kind=int_kind) :: n_bad_sst, n_bad_sss, n_ocn
-   !    n_bad_sst = 0; n_bad_sss = 0; n_ocn = 0
-   !    call icepack_query_parameters(secday_out=secday)
-   !    call icepack_warnings_flush(nu_diag)
-   !    if (icepack_warnings_aborted()) call abort_ice(error_message=subname, file=__FILE__, line=__LINE__)
-   !    !---------------------------------------------------------------------
-   !    ! 1) Determine forcing year (supports ycycle logic used elsewhere)
-   !    !---------------------------------------------------------------------
-   !    modadj = abs((min(0,myear-fyear_init)/ycycle + 1) * ycycle)
-   !    fyr    = fyear_init + mod(myear - fyear_init + modadj, ycycle)
-   !    if (fyr /= last_fyr) then
-   !       call AFIM_files(fyr)                 ! updates F_AFIM -> ORAS_YYYY.nc
-   !       last_fyr = fyr
-   !       last_rec_slot(1) = -999999
-   !       last_rec_slot(2) = -999999
-   !       if (my_task == master_task) then
-   !          write(nu_diag,*) subname,' switching forcing year -> ', fyr
-   !          write(nu_diag,*) subname,' F_AFIM = ', trim(F_AFIM)
-   !       endif
-   !    endif
-   !    !---------------------------------------------------------------------
-   !    ! 2) Determine which two records we need (rec0=slot1, rec1=slot2),
-   !    !    and set interpolation coefficients c1intp/c2intp.
-   !    !---------------------------------------------------------------------
-   !    dataloc = 2  ! data located at end of interval (matches your prior usage)
-   !    if (trim(ocn_data_freq) == 'monthly') then
-   !       maxrec = months_per_year
-   !       ! midpoint is at day 15, 00:00; treat (mday<15) as first half
-   !       first_half = (int(mday) < 15) .or. (int(mday) == 15 .and. int(msec) == 0)
-   !       if (first_half) then
-   !          ! slot2 = current month, slot1 = previous month (wrap within same file)
-   !          rec1 = max(1, min(maxrec, mmonth))
-   !          rec0 = rec1 - 1
-   !          if (rec0 < 1) rec0 = maxrec
-   !          call interp_coeff_monthly(2)   ! recslot=2 => first half (per your routine)
-   !       else ! slot1 = current month, slot2 = next month (wrap within same file)
-   !          rec0 = max(1, min(maxrec, mmonth))
-   !          rec1 = rec0 + 1
-   !          if (rec1 > maxrec) rec1 = 1
-   !          call interp_coeff_monthly(1)   ! recslot=1 => second half
-   !       endif
-   !    elseif (trim(ocn_data_freq) == 'weekly') then
-   !       maxrec = days_per_year / 7
-   !       rec1   = int( real(yday-1,kind=dbl_kind) / 7._dbl_kind ) + 1
-   !       rec1   = max(1, min(maxrec, rec1))
-   !       rec0   = max(1, rec1-1)
-   !       call interp_coeff(rec1, 2, secday*7._dbl_kind, dataloc)
-   !    else ! default to daily
-   !       maxrec = days_per_year
-   !       rec1   = int(yday)
-   !       rec1   = max(1, min(maxrec, rec1))
-   !       rec0   = max(1, rec1-1)
-   !       call interp_coeff(rec1, 2, secday, dataloc)
-   !    endif
-   !    !---------------------------------------------------------------------
-   !    ! 3) Read only when needed (record changed since last call).
-   !    !    slot1 holds rec0, slot2 holds rec1.
-   !    !---------------------------------------------------------------------
-   !    need_read_slot1 = (rec0 /= last_rec_slot(1))
-   !    need_read_slot2 = (rec1 /= last_rec_slot(2))
-   !    if (need_read_slot1 .or. need_read_slot2) then
-   !       if (my_task == master_task) then
-   !          write(nu_diag,*) subname,' reading records rec0/rec1 = ', rec0, rec1
-   !          write(nu_diag,*) subname,' c1intp/c2intp = ', c1intp, c2intp
-   !          write(nu_diag,*) subname,' file = ', trim(F_AFIM)
-   !       endif
-   !       call ice_open_nc(F_AFIM, fid)
-   !       ! --- slot 1 (rec0) ---
-   !       if (need_read_slot1) then
-   !          call ice_read_nc(fid, rec0, 'sst', sst_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !          call ice_read_nc(fid, rec0, 'sss', sss_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !          call ice_read_nc(fid, rec0, 'u'  , uocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !          call ice_read_nc(fid, rec0, 'v'  , vocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !          last_rec_slot(1) = rec0
-   !       endif
-   !       ! --- slot 2 (rec1) ---
-   !       if (need_read_slot2) then
-   !          if (rec1 == rec0) then
-   !             ! avoid duplicate reads; just copy slot1 -> slot2
-   !             sst_data (:,:,2,:) = sst_data (:,:,1,:)
-   !             sss_data (:,:,2,:) = sss_data (:,:,1,:)
-   !             uocn_data(:,:,2,:) = uocn_data(:,:,1,:)
-   !             vocn_data(:,:,2,:) = vocn_data(:,:,1,:)
-   !          else
-   !             call ice_read_nc(fid, rec1, 'sst', sst_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !             call ice_read_nc(fid, rec1, 'sss', sss_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !             call ice_read_nc(fid, rec1, 'u'  , uocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !             call ice_read_nc(fid, rec1, 'v'  , vocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
-   !          endif
-   !          last_rec_slot(2) = rec1
-   !       endif
-   !       call ice_close_nc(fid)
-   !    endif
-   !    if ((debug_forcing .or. local_debug) .and. (my_task == master_task)) then
-   !       write(nu_diag,*) subname,' raw record stats (slot1=rec0, slot2=rec1):'
-   !       vmin = global_minval(sst_data(:,:,1,:), distrb_info, tmask)
-   !       vmax = global_maxval(sst_data(:,:,1,:), distrb_info, tmask)
-   !       write(nu_diag,*) subname,'  sst_data slot1 min/max ', vmin, vmax
-   !       vmin = global_minval(sst_data(:,:,2,:), distrb_info, tmask)
-   !       vmax = global_maxval(sst_data(:,:,2,:), distrb_info, tmask)
-   !       write(nu_diag,*) subname,'  sst_data slot2 min/max ', vmin, vmax
-   !       vmin = global_minval(sss_data(:,:,1,:), distrb_info, tmask)
-   !       vmax = global_maxval(sss_data(:,:,1,:), distrb_info, tmask)
-   !       write(nu_diag,*) subname,'  sss_data slot1 min/max ', vmin, vmax
-   !       vmin = global_minval(sss_data(:,:,2,:), distrb_info, tmask)
-   !       vmax = global_maxval(sss_data(:,:,2,:), distrb_info, tmask)
-   !       write(nu_diag,*) subname,'  sss_data slot2 min/max ', vmin, vmax
-   !    endif
-   !    !---------------------------------------------------------------------
-   !    ! 4) Apply interpolation each timestep (NO nested OpenMP; no races)
-   !    !    Now: SST/SSS use ice-dependent weighting and restoring timescales.
-   !    !---------------------------------------------------------------------
-   !    TT_loc = max(T_T, 1.0e-6_dbl_kind)   ! days, but never <=0
-   !    TS_loc = max(T_S, 1.0e-6_dbl_kind)
-   !    a0_loc = max(a_0, 1.0e-12_dbl_kind)      ! avoid divide-by-zero
-   !    pw_loc = max(p_w, 1.0_dbl_kind)
-   !    ! convert timescales from days to seconds 
-   !    tauT = max(dt, T_T * secday)
-   !    tauS = max(dt, T_S * secday)
-   !    ! restore factors (capped at 1 for stability if dt > tau)
-   !    facT = min(c1, dt / tauT)
-   !    facS = min(c1, dt / tauS)
-   !    if (my_task == master_task .and. istep == 1) then
-   !       write(nu_diag,*) subname,' T_T=',T_T,' TT_loc=',TT_loc,' tauT(s)=',tauT,' facT=',facT
-   !       write(nu_diag,*) subname,' T_S=',T_S,' TS_loc=',TS_loc,' tauS(s)=',tauS,' facS=',facS
-   !       write(nu_diag,*) subname,' a_0=',a0_loc,' p_w=',pw_loc,' ocn_data_freq=',trim(ocn_data_freq)
-   !    endif
-   !    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(iblk,i,j, &
-   !    !$OMP   sst_tgt,sss_tgt,u_tgt,v_tgt, a,w,wraw,sst_tgt_eff, Tf_loc, sst_sc_floor)
-   !    do iblk = 1, nblocks
-   !       do j = 1, ny_block
-   !          do i = 1, nx_block
-   !             if (hm(i,j,iblk) == c0) then ! if land (hm=0) then set ocn fields to 0
-   !                sst (i,j,iblk) = c0
-   !                sss (i,j,iblk) = c0
-   !                uocn(i,j,iblk) = c0
-   !                vocn(i,j,iblk) = c0
-   !             else
-   !                n_ocn = n_ocn + 1
-   !                !------------------------------------------------------
-   !                ! Time interpolation of external forcing records using a linear interpolation 
-   !                ! between two records (index 1 and 2) using coefficients (c1intp,c2intp)
-   !                ! computed earlier by interp_coeff(). The record selection depends on 
-   !                ! ocn_data_freq ('daily','weekly','monthly'). This avoids step-wise "record updates"
-   !                ! and ensures that SST/SSS/uocn/vocn vary smoothly in time at each model timestep.
-   !                !------------------------------------------------------
-   !                sst_tgt = c1intp*sst_data (i,j,1,iblk) + c2intp*sst_data (i,j,2,iblk)
-   !                sss_tgt = c1intp*sss_data (i,j,1,iblk) + c2intp*sss_data (i,j,2,iblk)
-   !                u_tgt   = c1intp*uocn_data(i,j,1,iblk) + c2intp*uocn_data(i,j,2,iblk)
-   !                v_tgt   = c1intp*vocn_data(i,j,1,iblk) + c2intp*vocn_data(i,j,2,iblk)
-   !                ! 1) Ensure targets are finite (ORAS SST can be NaN under ice)
-   !                !    Use a local freezing point as the physically consistent fallback.
-   !                Tf_loc  = Tf(i,j,iblk)
-   !                if (.not. ieee_is_finite(Tf_loc)) Tf_loc = -1.8_dbl_kind
-   !                ! Catch NaN OR out-of-range fill values
-   !                if ((.not. ieee_is_finite(sst_tgt)) .or. (sst_tgt < -10._dbl_kind) .or. (sst_tgt > 50._dbl_kind)) then
-   !                   n_bad_sst = n_bad_sst + 1
-   !                   sst_tgt = Tf_loc
-   !                endif
-   !                if ((.not. ieee_is_finite(sss_tgt)) .or. (sss_tgt <  0._dbl_kind) .or. (sss_tgt > 60._dbl_kind)) then
-   !                   n_bad_sss = n_bad_sss + 1
-   !                   sss_tgt = 34._dbl_kind
-   !                endif
-   !                ! 2) Ensure the prognostic state is finite before nudging
-   !                if (.not. ieee_is_finite(sst(i,j,iblk))) sst(i,j,iblk) = sst_tgt
-   !                if (.not. ieee_is_finite(sss(i,j,iblk))) sss(i,j,iblk) = sss_tgt
-   !                !------------------------------------------------------
-   !                ! Open-water weight w(aice), thermodynamic restoring based on ice
-   !                ! concentration to prevent imposing open-ocean SST/SSS under 
-   !                ! consolidated ice.
-   !                ! w=1 : open water (aice ~ 0)  -> full restoring to forcing
-   !                ! w=0 : consolidated ice (aice >= a0) -> no open-ocean restoring
-   !                ! a0  : concentration threshold (ice_in -> a_0; default 0.15)
-   !                ! p_w : optional exponent controlling transition sharpness
-   !                !       (ice_in -> p_w; default 1.0). Larger p_w makes the taper more ... edgey!?! 
-   !                !------------------------------------------------------
-   !                a    = aice(i,j,iblk)
-   !                if (.not. ieee_is_finite(a)) a = 0._dbl_kind
-   !                wraw = (a0_loc - a) / a0_loc
-   !                w    = min(c1, max(c0, wraw))
-   !                if (pw_loc > c1) w = w**pw_loc
-   !                !------------------------------------------------------
-   !                ! SST under ice: freezing-point constrained restoring
-   !                ! Rationale: In a slab mixed-layer, prescribing or strongly restoring to
-   !                ! open-ocean SST under winter sea ice could likely inject unrealistically
-   !                ! warm water and suppress ice growth (biasing SIA/FIA low). Under consolidated
-   !                ! ice the mixed-layer is typically close to the local freezing point; therefore 
-   !                ! the aim here is to blend the target SST toward `Tf` as ice concentration increases.
-   !                ! Effective target:
-   !                !   T_tgt_eff = w*T_forcing + (1-w)*Tf
-   !                ! Then apply a relaxation with timescale T_T (days), which controls how tightly
-   !                ! the slab mixed-layer SST follows the external product in open water.
-   !                !------------------------------------------------------
-   !                sst_tgt_eff   = w*sst_tgt + (c1 - w)*Tf_loc
-   !                sst(i,j,iblk) = sst(i,j,iblk) + facT*(sst_tgt_eff - sst(i,j,iblk))
-   !                !------------------------------------------------------
-   !                ! SSS: open-water restoring only (tapered by w)
-   !                ! Rationale: Salinity under ice is strongly influenced by local freezing/melting
-   !                ! and brine rejection. Aggressive restoring of SSS under sea ice could overwrite
-   !                ! this evolution and indirectly bias Tf and growth rates. Therefore I apply a 
-   !                ! restoring in open water and progressively turn it off as ice consolidates.
-   !                ! Equivalent to restoring toward:
-   !                !   S_tgt = w*S_forcing + (1-w)*S_model
-   !                ! Implemented as:
-   !                !   dS/dt ~ (w/tauS) * (S_forcing - S_model)
-   !                ! with timescale T_S (days).
-   !                !------------------------------------------------------
-   !                sss(i,j,iblk) = sss(i,j,iblk) + facS*w*(sss_tgt - sss(i,j,iblk))
-   !                !------------------------------------------------------
-   !                ! 6) IMPORTANT: do NOT hard-floor SST at Tf (kills freeze initiation in some orderings)
-   !                !    If you want a safety limiter, allow modest supercooling:
-   !                sst_sc_floor  = Tf_loc - dT_sc_max
-   !                sst(i,j,iblk) = max(sst(i,j,iblk), sst_sc_floor)
-   !                !------------------------------------------------------
-   !                ! Ocean currents: accept time-interpolated u/v as provided.
-   !                ! Rationale: uocn/vocn represent the large-scale ocean forcing from the reanalysis
-   !                ! and provide the advective/momentum driver for ice drift and ice–ocean relative
-   !                ! motion. Tapering currents based on sea ice concentration (`aice`) would likely
-   !                ! introduce an ad hoc momentum sink tied to the ice state and possibly confound
-   !                ! mechanical sensitivity experiments.
-   !                uocn(i,j,iblk) = u_tgt
-   !                vocn(i,j,iblk) = v_tgt
-   !             endif
-   !          enddo
-   !       enddo
-   !    enddo
-   !    !$OMP END PARALLEL DO
-   !    if ((debug_forcing .or. local_debug) .and. my_task == master_task) then
-   !       write(nu_diag,*) subname,' bad_sst=',n_bad_sst,' bad_sss=',n_bad_sss!,' ocean_pts=',n_ocn
-   !    endif
-   !    ! Recomputes freezing temperature after SSS update
-   !    call ocn_freezing_temperaturell
-   !    ! helpful prints if debuggging
-   !    if ((debug_forcing .or. local_debug) .and. my_task == master_task) then
-   !       vmin = global_minval(aice, distrb_info, tmask)
-   !       vmax = global_maxval(aice, distrb_info, tmask)
-   !       write(nu_diag,*) subname,' aice min/max ', vmin, vmax
-   !       write(nu_diag,*) subname,' global min/max after update (rec0/rec1): ', rec0, rec1
-   !       vmin = global_minval(sst ,distrb_info,tmask)
-   !       vmax = global_maxval(sst ,distrb_info,tmask)
-   !       write(nu_diag,*) subname,'  sst ', vmin, vmax
-   !       vmin = global_minval(sss ,distrb_info,tmask)
-   !       vmax = global_maxval(sss ,distrb_info,tmask)
-   !       write(nu_diag,*) subname,'  sss ', vmin, vmax
-   !       vmin = global_minval(uocn,distrb_info,umask)
-   !       vmax = global_maxval(uocn,distrb_info,umask)
-   !       write(nu_diag,*) subname,'  uocn', vmin, vmax
-   !       vmin = global_minval(vocn,distrb_info,umask)
-   !       vmax = global_maxval(vocn,distrb_info,umask)
-   !       write(nu_diag,*) subname,'  vocn', vmin, vmax
-   !    endif
-   ! end subroutine AFIM_data
    subroutine AFIM_data(dt)
-
       use ice_blocks, only            : nx_block, ny_block
       use ice_read_write, only        : ice_read_nc, ice_open_nc, ice_close_nc
       use ice_global_reductions, only : global_minval, global_maxval
       use ice_domain, only            : distrb_info, nblocks
-      use ice_flux, only              : sss, sst, uocn, vocn, Tf
+      use ice_flux, only              : sss, sst, uocn, vocn, Tf ! CICE INTERNAL OCEAN 
       use ice_grid, only              : hm, tmask, umask
       use ice_calendar, only          : days_per_year, months_per_year, mmonth, myear, yday, mday, msec
-      use ice_state, only             : aice
+      use ice_restart_shared, only    : restart
+      use ice_state, only             : aice     ! needed for w(aice)
       use, intrinsic :: ieee_arithmetic, only : ieee_is_finite
       implicit none
-
-      real(kind=dbl_kind), intent(in) :: dt
-
-      character(len=*), parameter :: subname = '(AFIM_data)'
-
-      !----------------------------
-      ! Tunable guards (debug-phase)
-      !----------------------------
-      real(kind=dbl_kind), parameter :: dT_sc_max      = 0.20_dbl_kind
-      real(kind=dbl_kind), parameter :: Tf_default     = -1.8_dbl_kind
-      real(kind=dbl_kind), parameter :: sss_default    = 34.0_dbl_kind
-      real(kind=dbl_kind), parameter :: sss_fill_floor = 20.0_dbl_kind   ! DEBUG: treat SSS<20 as fill in SO
-      real(kind=dbl_kind), parameter :: sss_hi_thresh  = 60.0_dbl_kind
-      real(kind=dbl_kind), parameter :: sst_lo_thresh  = -10.0_dbl_kind
-      real(kind=dbl_kind), parameter :: sst_hi_thresh  =  50.0_dbl_kind
-      real(kind=dbl_kind), parameter :: ispd_thresh    =   2.5_dbl_kind
-
-      integer(kind=int_kind) :: fid, i, j, iblk
-      integer(kind=int_kind) :: rec0, rec1, maxrec, dataloc, fyr, modadj
-      logical                :: need_read_slot1, need_read_slot2, first_half
-
-      real(kind=dbl_kind) :: secday
-      real(kind=dbl_kind) :: sst_tgt, sss_tgt, u_tgt, v_tgt
       real(kind=dbl_kind) :: Tf_loc, sst_sc_floor
-      real(kind=dbl_kind) :: a, w, wraw, sst_tgt_eff
-      real(kind=dbl_kind) :: tauT, tauS, facT, facS, TT_loc, TS_loc, a0_loc, pw_loc
-      real(kind=dbl_kind) :: vmin, vmax
-
-      integer(kind=int_kind) :: nstep_day, nstep_2hr
-      logical                :: do_dbg
-
-      integer(kind=int_kind) :: n_ocn, n_bad_sst, n_bad_sss, n_bad_uv, n_nonfinite_state
-
-      integer(kind=int_kind), save :: last_fyr = -999999
-      integer(kind=int_kind), save :: last_rec_slot(2) = (/ -999999, -999999 /)
-
-      n_ocn             = 0
-      n_bad_sst         = 0
-      n_bad_sss         = 0
-      n_bad_uv          = 0
-      n_nonfinite_state = 0
-
+      real(kind=dbl_kind), parameter :: dT_sc_max = 0.20_dbl_kind   ! allow 0.2 C supercooling (tunable)
+      ! variable assignments
+      real(kind=dbl_kind), intent(in) :: dt
+      integer(kind=int_kind)          :: fid, i, j, iblk, rec0, rec1, maxrec, dataloc, fyr, modadj
+      real(kind=dbl_kind)             :: secday, sst_tgt, sss_tgt, u_tgt, v_tgt, vmin, vmax
+      logical                         :: need_read_slot1, need_read_slot2, first_half
+      character(len=*), parameter     :: subname = '(AFIM_data)'
+      ! --- cached state (persists across calls) ---
+      integer(kind=int_kind), save    :: last_fyr = -999999
+      integer(kind=int_kind), save    :: last_rec_slot(2) = (/ -999999, -999999 /)  ! slot1, slot2
+      ! --- local vars for weighted restoring ---
+      real(kind=dbl_kind)             :: a, w, wraw, sst_tgt_eff, tauT, tauS, facT, facS, TT_loc, TS_loc, a0_loc, pw_loc
+      integer(kind=int_kind) :: n_bad_sst, n_bad_sss, n_ocn
+      n_bad_sst = 0; n_bad_sss = 0; n_ocn = 0
       call icepack_query_parameters(secday_out=secday)
       call icepack_warnings_flush(nu_diag)
       if (icepack_warnings_aborted()) call abort_ice(error_message=subname, file=__FILE__, line=__LINE__)
-
-      nstep_day = max(1_int_kind, int(secday/dt + 0.5_dbl_kind))
-      nstep_2hr = max(1_int_kind, int((2.0_dbl_kind*3600.0_dbl_kind)/dt + 0.5_dbl_kind))
-      do_dbg   = (debug_forcing .or. local_debug)
-
-      if (my_task == master_task) then
-         write(nu_diag,*) subname,' ENTER istep=',istep,' yday=',yday,' msec=',msec
-         call icepack_warnings_flush(nu_diag)
-      endif
-
       !---------------------------------------------------------------------
-      ! 1) forcing year
+      ! 1) Determine forcing year (supports ycycle logic used elsewhere)
       !---------------------------------------------------------------------
       modadj = abs((min(0,myear-fyear_init)/ycycle + 1) * ycycle)
       fyr    = fyear_init + mod(myear - fyear_init + modadj, ycycle)
-
       if (fyr /= last_fyr) then
-         call AFIM_files(fyr)
+         call AFIM_files(fyr)                 ! updates F_AFIM -> ORAS_YYYY.nc
          last_fyr = fyr
          last_rec_slot(1) = -999999
          last_rec_slot(2) = -999999
          if (my_task == master_task) then
             write(nu_diag,*) subname,' switching forcing year -> ', fyr
             write(nu_diag,*) subname,' F_AFIM = ', trim(F_AFIM)
-            call icepack_warnings_flush(nu_diag)
          endif
       endif
-
       !---------------------------------------------------------------------
-      ! 2) record selection + coeffs
+      ! 2) Determine which two records we need (rec0=slot1, rec1=slot2),
+      !    and set interpolation coefficients c1intp/c2intp.
       !---------------------------------------------------------------------
-      dataloc = 2
-
+      dataloc = 2  ! data located at end of interval (matches your prior usage)
       if (trim(ocn_data_freq) == 'monthly') then
          maxrec = months_per_year
+         ! midpoint is at day 15, 00:00; treat (mday<15) as first half
          first_half = (int(mday) < 15) .or. (int(mday) == 15 .and. int(msec) == 0)
          if (first_half) then
+            ! slot2 = current month, slot1 = previous month (wrap within same file)
             rec1 = max(1, min(maxrec, mmonth))
             rec0 = rec1 - 1
             if (rec0 < 1) rec0 = maxrec
-            call interp_coeff_monthly(2)
-         else
+            call interp_coeff_monthly(2)   ! recslot=2 => first half (per your routine)
+         else ! slot1 = current month, slot2 = next month (wrap within same file)
             rec0 = max(1, min(maxrec, mmonth))
             rec1 = rec0 + 1
             if (rec1 > maxrec) rec1 = 1
-            call interp_coeff_monthly(1)
+            call interp_coeff_monthly(1)   ! recslot=1 => second half
          endif
       elseif (trim(ocn_data_freq) == 'weekly') then
          maxrec = days_per_year / 7
@@ -2386,196 +2071,210 @@ subroutine AFIM_data(dt)
          rec1   = max(1, min(maxrec, rec1))
          rec0   = max(1, rec1-1)
          call interp_coeff(rec1, 2, secday*7._dbl_kind, dataloc)
-      else
+      else ! default to daily
          maxrec = days_per_year
          rec1   = int(yday)
          rec1   = max(1, min(maxrec, rec1))
          rec0   = max(1, rec1-1)
          call interp_coeff(rec1, 2, secday, dataloc)
       endif
-
       !---------------------------------------------------------------------
-      ! 3) read when needed
+      ! 3) Read only when needed (record changed since last call).
+      !    slot1 holds rec0, slot2 holds rec1.
       !---------------------------------------------------------------------
       need_read_slot1 = (rec0 /= last_rec_slot(1))
       need_read_slot2 = (rec1 /= last_rec_slot(2))
-
       if (need_read_slot1 .or. need_read_slot2) then
-
          if (my_task == master_task) then
             write(nu_diag,*) subname,' reading records rec0/rec1 = ', rec0, rec1
             write(nu_diag,*) subname,' c1intp/c2intp = ', c1intp, c2intp
             write(nu_diag,*) subname,' file = ', trim(F_AFIM)
-            call icepack_warnings_flush(nu_diag)
          endif
-
          call ice_open_nc(F_AFIM, fid)
-
+         ! --- slot 1 (rec0) ---
          if (need_read_slot1) then
-            call ice_read_nc(fid, rec0, 'sst', sst_data(:,:,1,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
-            call ice_read_nc(fid, rec0, 'sss', sss_data(:,:,1,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
-            call ice_read_nc(fid, rec0, 'u',   uocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
-            call ice_read_nc(fid, rec0, 'v',   vocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+            call ice_read_nc(fid, rec0, 'sst', sst_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+            call ice_read_nc(fid, rec0, 'sss', sss_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+            call ice_read_nc(fid, rec0, 'u'  , uocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+            call ice_read_nc(fid, rec0, 'v'  , vocn_data(:,:,1,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
             last_rec_slot(1) = rec0
          endif
-
+         ! --- slot 2 (rec1) ---
          if (need_read_slot2) then
             if (rec1 == rec0) then
+               ! avoid duplicate reads; just copy slot1 -> slot2
                sst_data (:,:,2,:) = sst_data (:,:,1,:)
                sss_data (:,:,2,:) = sss_data (:,:,1,:)
                uocn_data(:,:,2,:) = uocn_data(:,:,1,:)
                vocn_data(:,:,2,:) = vocn_data(:,:,1,:)
             else
-               call ice_read_nc(fid, rec1, 'sst', sst_data(:,:,2,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
-               call ice_read_nc(fid, rec1, 'sss', sss_data(:,:,2,:),  debug_forcing, field_loc=field_loc_center,  field_type=field_type_scalar)
-               call ice_read_nc(fid, rec1, 'u',   uocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
-               call ice_read_nc(fid, rec1, 'v',   vocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_NEcorner, field_type=field_type_vector)
+               call ice_read_nc(fid, rec1, 'sst', sst_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+               call ice_read_nc(fid, rec1, 'sss', sss_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+               call ice_read_nc(fid, rec1, 'u'  , uocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
+               call ice_read_nc(fid, rec1, 'v'  , vocn_data(:,:,2,:), debug_forcing, field_loc=field_loc_center, field_type=field_type_scalar)
             endif
             last_rec_slot(2) = rec1
          endif
-
          call ice_close_nc(fid)
-
-         if ((do_dbg) .and. (my_task == master_task)) then
-            write(nu_diag,*) subname,' raw record stats (masked):'
-            vmin = global_minval(sst_data(:,:,1,:), distrb_info, tmask); vmax = global_maxval(sst_data(:,:,1,:), distrb_info, tmask)
-            write(nu_diag,*) subname,'  sst_data slot1 min/max ', vmin, vmax
-            vmin = global_minval(sss_data(:,:,1,:), distrb_info, tmask); vmax = global_maxval(sss_data(:,:,1,:), distrb_info, tmask)
-            write(nu_diag,*) subname,'  sss_data slot1 min/max ', vmin, vmax
-            call icepack_warnings_flush(nu_diag)
-         endif
-
       endif
-
+      if ((debug_forcing .or. local_debug) .and. (my_task == master_task)) then
+         write(nu_diag,*) subname,' raw record stats (slot1=rec0, slot2=rec1):'
+         vmin = global_minval(sst_data(:,:,1,:), distrb_info, tmask)
+         vmax = global_maxval(sst_data(:,:,1,:), distrb_info, tmask)
+         write(nu_diag,*) subname,'  sst_data slot1 min/max ', vmin, vmax
+         vmin = global_minval(sst_data(:,:,2,:), distrb_info, tmask)
+         vmax = global_maxval(sst_data(:,:,2,:), distrb_info, tmask)
+         write(nu_diag,*) subname,'  sst_data slot2 min/max ', vmin, vmax
+         vmin = global_minval(sss_data(:,:,1,:), distrb_info, tmask)
+         vmax = global_maxval(sss_data(:,:,1,:), distrb_info, tmask)
+         write(nu_diag,*) subname,'  sss_data slot1 min/max ', vmin, vmax
+         vmin = global_minval(sss_data(:,:,2,:), distrb_info, tmask)
+         vmax = global_maxval(sss_data(:,:,2,:), distrb_info, tmask)
+         write(nu_diag,*) subname,'  sss_data slot2 min/max ', vmin, vmax
+      endif
       !---------------------------------------------------------------------
-      ! 4) timescales + factors
+      ! 4) Apply interpolation each timestep (NO nested OpenMP; no races)
+      !    Now: SST/SSS use ice-dependent weighting and restoring timescales.
       !---------------------------------------------------------------------
-      TT_loc = max(T_T, 1.0e-6_dbl_kind)
+      TT_loc = max(T_T, 1.0e-6_dbl_kind)   ! days, but never <=0
       TS_loc = max(T_S, 1.0e-6_dbl_kind)
-      a0_loc = max(a_0, 1.0e-12_dbl_kind)
+      a0_loc = max(a_0, 1.0e-12_dbl_kind)      ! avoid divide-by-zero
       pw_loc = max(p_w, 1.0_dbl_kind)
-
-      tauT = max(dt, TT_loc * secday)
-      tauS = max(dt, TS_loc * secday)
+      ! convert timescales from days to seconds 
+      tauT = max(dt, T_T * secday)
+      tauS = max(dt, T_S * secday)
+      ! restore factors (capped at 1 for stability if dt > tau)
       facT = min(c1, dt / tauT)
       facS = min(c1, dt / tauS)
-
-      if (my_task == master_task) then
+      if (my_task == master_task .and. istep == 1) then
          write(nu_diag,*) subname,' T_T=',T_T,' TT_loc=',TT_loc,' tauT(s)=',tauT,' facT=',facT
          write(nu_diag,*) subname,' T_S=',T_S,' TS_loc=',TS_loc,' tauS(s)=',tauS,' facS=',facS
          write(nu_diag,*) subname,' a_0=',a0_loc,' p_w=',pw_loc,' ocn_data_freq=',trim(ocn_data_freq)
-         call icepack_warnings_flush(nu_diag)
       endif
-
-   !$OMP PARALLEL DO DEFAULT(SHARED) &
-   !$OMP PRIVATE(iblk,i,j, sst_tgt,sss_tgt,u_tgt,v_tgt, Tf_loc, sst_sc_floor, a,w,wraw,sst_tgt_eff) &
-   !$OMP REDUCTION(+:n_ocn,n_bad_sst,n_bad_sss,n_bad_uv,n_nonfinite_state)
+      !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(iblk,i,j, &
+      !$OMP   sst_tgt,sss_tgt,u_tgt,v_tgt, a,w,wraw,sst_tgt_eff, Tf_loc, sst_sc_floor)
       do iblk = 1, nblocks
          do j = 1, ny_block
             do i = 1, nx_block
-
-               if (hm(i,j,iblk) == c0) then
+               if (hm(i,j,iblk) == c0) then ! if land (hm=0) then set ocn fields to 0
                   sst (i,j,iblk) = c0
                   sss (i,j,iblk) = c0
                   uocn(i,j,iblk) = c0
                   vocn(i,j,iblk) = c0
                else
                   n_ocn = n_ocn + 1
-
+                  !------------------------------------------------------
+                  ! Time interpolation of external forcing records using a linear interpolation 
+                  ! between two records (index 1 and 2) using coefficients (c1intp,c2intp)
+                  ! computed earlier by interp_coeff(). The record selection depends on 
+                  ! ocn_data_freq ('daily','weekly','monthly'). This avoids step-wise "record updates"
+                  ! and ensures that SST/SSS/uocn/vocn vary smoothly in time at each model timestep.
+                  !------------------------------------------------------
                   sst_tgt = c1intp*sst_data (i,j,1,iblk) + c2intp*sst_data (i,j,2,iblk)
                   sss_tgt = c1intp*sss_data (i,j,1,iblk) + c2intp*sss_data (i,j,2,iblk)
                   u_tgt   = c1intp*uocn_data(i,j,1,iblk) + c2intp*uocn_data(i,j,2,iblk)
                   v_tgt   = c1intp*vocn_data(i,j,1,iblk) + c2intp*vocn_data(i,j,2,iblk)
-
-                  Tf_loc = Tf(i,j,iblk)
-                  if (.not. ieee_is_finite(Tf_loc)) Tf_loc = Tf_default
-
-                  ! SSS guard (treat low salinity as fill in SO debug)
-                  if ((.not. ieee_is_finite(sss_tgt)) .or. (sss_tgt < sss_fill_floor) .or. (sss_tgt > sss_hi_thresh)) then
-                     n_bad_sss = n_bad_sss + 1
-                     sss_tgt   = sss_default
-                     ! if SSS was fill-like, SST under ice is usually also untrustworthy
-                     sst_tgt   = Tf_loc
-                  endif
-
-                  ! SST guard
-                  if ((.not. ieee_is_finite(sst_tgt)) .or. (sst_tgt < sst_lo_thresh) .or. (sst_tgt > sst_hi_thresh)) then
+                  ! 1) Ensure targets are finite (ORAS SST can be NaN under ice)
+                  !    Use a local freezing point as the physically consistent fallback.
+                  Tf_loc  = Tf(i,j,iblk)
+                  if (.not. ieee_is_finite(Tf_loc)) Tf_loc = -1.8_dbl_kind
+                  ! Catch NaN OR out-of-range fill values
+                  if ((.not. ieee_is_finite(sst_tgt)) .or. (sst_tgt < -10._dbl_kind) .or. (sst_tgt > 50._dbl_kind)) then
                      n_bad_sst = n_bad_sst + 1
-                     sst_tgt   = Tf_loc
-                  endif
-
-                  ! Currents guard
-                  if ((.not. ieee_is_finite(u_tgt)) .or. (abs(u_tgt) > ispd_thresh)) then
-                     n_bad_uv = n_bad_uv + 1
-                     u_tgt = c0
+                     sst_tgt = Tf_loc
                   endif
-                  if ((.not. ieee_is_finite(v_tgt)) .or. (abs(v_tgt) > ispd_thresh)) then
-                     n_bad_uv = n_bad_uv + 1
-                     v_tgt = c0
-                  endif
-
-                  if (.not. ieee_is_finite(sst(i,j,iblk))) then
-                     sst(i,j,iblk) = sst_tgt
-                     n_nonfinite_state = n_nonfinite_state + 1
-                  endif
-                  if (.not. ieee_is_finite(sss(i,j,iblk))) then
-                     sss(i,j,iblk) = sss_tgt
-                     n_nonfinite_state = n_nonfinite_state + 1
+                  if ((.not. ieee_is_finite(sss_tgt)) .or. (sss_tgt <  0._dbl_kind) .or. (sss_tgt > 60._dbl_kind)) then
+                     n_bad_sss = n_bad_sss + 1
+                     sss_tgt = 34._dbl_kind
                   endif
-
-                  a = aice(i,j,iblk)
-                  if (.not. ieee_is_finite(a)) a = c0
-
+                  ! 2) Ensure the prognostic state is finite before nudging
+                  if (.not. ieee_is_finite(sst(i,j,iblk))) sst(i,j,iblk) = sst_tgt
+                  if (.not. ieee_is_finite(sss(i,j,iblk))) sss(i,j,iblk) = sss_tgt
+                  !------------------------------------------------------
+                  ! Open-water weight w(aice), thermodynamic restoring based on ice
+                  ! concentration to prevent imposing open-ocean SST/SSS under 
+                  ! consolidated ice.
+                  ! w=1 : open water (aice ~ 0)  -> full restoring to forcing
+                  ! w=0 : consolidated ice (aice >= a0) -> no open-ocean restoring
+                  ! a0  : concentration threshold (ice_in -> a_0; default 0.15)
+                  ! p_w : optional exponent controlling transition sharpness
+                  !       (ice_in -> p_w; default 1.0). Larger p_w makes the taper more ... edgey!?! 
+                  !------------------------------------------------------
+                  a    = aice(i,j,iblk)
+                  if (.not. ieee_is_finite(a)) a = 0._dbl_kind
                   wraw = (a0_loc - a) / a0_loc
                   w    = min(c1, max(c0, wraw))
                   if (pw_loc > c1) w = w**pw_loc
-
+                  !------------------------------------------------------
+                  ! SST under ice: freezing-point constrained restoring
+                  ! Rationale: In a slab mixed-layer, prescribing or strongly restoring to
+                  ! open-ocean SST under winter sea ice could likely inject unrealistically
+                  ! warm water and suppress ice growth (biasing SIA/FIA low). Under consolidated
+                  ! ice the mixed-layer is typically close to the local freezing point; therefore 
+                  ! the aim here is to blend the target SST toward `Tf` as ice concentration increases.
+                  ! Effective target:
+                  !   T_tgt_eff = w*T_forcing + (1-w)*Tf
+                  ! Then apply a relaxation with timescale T_T (days), which controls how tightly
+                  ! the slab mixed-layer SST follows the external product in open water.
+                  !------------------------------------------------------
                   sst_tgt_eff   = w*sst_tgt + (c1 - w)*Tf_loc
                   sst(i,j,iblk) = sst(i,j,iblk) + facT*(sst_tgt_eff - sst(i,j,iblk))
-
+                  !------------------------------------------------------
+                  ! SSS: open-water restoring only (tapered by w)
+                  ! Rationale: Salinity under ice is strongly influenced by local freezing/melting
+                  ! and brine rejection. Aggressive restoring of SSS under sea ice could overwrite
+                  ! this evolution and indirectly bias Tf and growth rates. Therefore I apply a 
+                  ! restoring in open water and progressively turn it off as ice consolidates.
+                  ! Equivalent to restoring toward:
+                  !   S_tgt = w*S_forcing + (1-w)*S_model
+                  ! Implemented as:
+                  !   dS/dt ~ (w/tauS) * (S_forcing - S_model)
+                  ! with timescale T_S (days).
+                  !------------------------------------------------------
+                  sss(i,j,iblk) = sss(i,j,iblk) + facS*w*(sss_tgt - sss(i,j,iblk))
+                  !------------------------------------------------------
+                  ! 6) IMPORTANT: do NOT hard-floor SST at Tf (kills freeze initiation in some orderings)
+                  !    If you want a safety limiter, allow modest supercooling:
                   sst_sc_floor  = Tf_loc - dT_sc_max
                   sst(i,j,iblk) = max(sst(i,j,iblk), sst_sc_floor)
-
-                  sss(i,j,iblk) = sss(i,j,iblk) + facS*w*(sss_tgt - sss(i,j,iblk))
-
+                  !------------------------------------------------------
+                  ! Ocean currents: accept time-interpolated u/v as provided.
+                  ! Rationale: uocn/vocn represent the large-scale ocean forcing from the reanalysis
+                  ! and provide the advective/momentum driver for ice drift and ice–ocean relative
+                  ! motion. Tapering currents based on sea ice concentration (`aice`) would likely
+                  ! introduce an ad hoc momentum sink tied to the ice state and possibly confound
+                  ! mechanical sensitivity experiments.
                   uocn(i,j,iblk) = u_tgt
                   vocn(i,j,iblk) = v_tgt
-
                endif
             enddo
          enddo
       enddo
-   !$OMP END PARALLEL DO
-
-      call ocn_freezing_temperature
-
-      ! “heartbeat” prints: first 10 steps always; then every 2 hours for first 2 days; then daily if debug
-      if (my_task == master_task) then
-            write(nu_diag,*) subname,' istep=',istep,' yday=',yday,' msec=',msec, &
-                           ' ocean=',n_ocn,' bad_sst=',n_bad_sst,' bad_sss=',n_bad_sss, &
-                           ' bad_uv=',n_bad_uv,' state_fixups=',n_nonfinite_state
-            vmin = global_minval(aice, distrb_info, tmask); vmax = global_maxval(aice, distrb_info, tmask)
-            write(nu_diag,*) subname,' aice min/max ', vmin, vmax
-            vmin = global_minval(sst,  distrb_info, tmask); vmax = global_maxval(sst,  distrb_info, tmask)
-            write(nu_diag,*) subname,' sst  min/max ', vmin, vmax
-            ! vmin = global_minval(sss,  distrb_info, tmask); vmax = global_maxval(sss,  distrb_info, tmask)
-            ! write(nu_diag,*) subname,' sss  min/max ', vmin, vmax
-            vmin = global_minval(Tf,   distrb_info, tmask); vmax = global_maxval(Tf,   distrb_info, tmask)
-            write(nu_diag,*) subname,' Tf   min/max ', vmin, vmax
-            call icepack_warnings_flush(nu_diag)
-      endif
-
-      if (my_task == master_task) then
-            write(nu_diag,*) subname,' HEARTBEAT istep=',istep,' yday=',yday,' msec=',msec, &
-                           ' rec0/rec1=',rec0,rec1,' c1intp/c2intp=',c1intp,c2intp
-            call icepack_warnings_flush(nu_diag)
+      !$OMP END PARALLEL DO
+      if ((debug_forcing .or. local_debug) .and. my_task == master_task) then
+         write(nu_diag,*) subname,' bad_sst=',n_bad_sst,' bad_sss=',n_bad_sss!,' ocean_pts=',n_ocn
       endif
-
-      if (my_task == master_task) then
-         write(nu_diag,*) subname,' EXIT istep=',istep
-         call icepack_warnings_flush(nu_diag)
+      ! Recomputes freezing temperature after SSS update
+      call ocn_freezing_temperaturell
+      ! helpful prints if debuggging
+      if ((debug_forcing .or. local_debug) .and. my_task == master_task) then
+         vmin = global_minval(aice, distrb_info, tmask)
+         vmax = global_maxval(aice, distrb_info, tmask)
+         write(nu_diag,*) subname,' aice min/max ', vmin, vmax
+         write(nu_diag,*) subname,' global min/max after update (rec0/rec1): ', rec0, rec1
+         vmin = global_minval(sst ,distrb_info,tmask)
+         vmax = global_maxval(sst ,distrb_info,tmask)
+         write(nu_diag,*) subname,'  sst ', vmin, vmax
+         vmin = global_minval(sss ,distrb_info,tmask)
+         vmax = global_maxval(sss ,distrb_info,tmask)
+         write(nu_diag,*) subname,'  sss ', vmin, vmax
+         vmin = global_minval(uocn,distrb_info,umask)
+         vmax = global_maxval(uocn,distrb_info,umask)
+         write(nu_diag,*) subname,'  uocn', vmin, vmax
+         vmin = global_minval(vocn,distrb_info,umask)
+         vmax = global_maxval(vocn,distrb_info,umask)
+         write(nu_diag,*) subname,'  vocn', vmin, vmax
       endif
-
    end subroutine AFIM_data
 
   !=======================================================================
-- 
2.43.7

